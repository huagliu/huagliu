<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Windows兼容Linux]]></title>
    <url>%2F2021%2F12%2F31%2FWindows%E5%85%BC%E5%AE%B9Linux%2F</url>
    <content type="text"><![CDATA[微软开发的 WSL 和 Windows Terminal 是在 Windows 上运行 Linux 的神器。 本文首先简述了 Linux 系统的发展历程，然后介绍了 Windows 兼容 Linux 的过程，最后记录了在 Windows 10 中安装 WSL 2 的过程。 Windows 系统兼容 Linux 历程参考 silaoA 的系列文章：Cygwin前传，Cygwin系列1 和 微软WSL，整理 Linux 系统的发展历程以及 Windows 兼容 Linux 的过程。视频资料：RevolutionOS, The Code (2001) (Linux Documentary). UNIX 与 GNU/Linux 1969年，AT&amp;T公司旗下的贝尔实验室的天才们Ken Thompson、Dennis Ritchie和Douglas McIlroy开发了UNIX操作系统。各种商业并购之后，UNIX商标权现归国际开放标准组织（The Open Group）所拥有。 各UNIX版本继续各自发展，呈现的差异越来越大，IEEE 在1985年牵头设立一个标准，叫“可移植操作系统接口”(Portable Operating System Interface，POSIX) 。其目的是保证软件系统接口规范的一致性，从而保障程序代码的兼容性。 1984年 Richard Matthew Stallman 发起了GNU计划(GNU is Not Unix)，计划开发一个完全兼容UNIX的自由软件系统，为此专门成立了自由软件基金会(Free Software Foundation，FSF)。FSF打算是搞成一个GNU/Hurd操作系统，其中Hurd是用来取代UNIX内核的新系统内核，GNU代表用户软件。FSF开发出了很多极其优秀的软件，名字和UNIX下的都相似甚至相同，从而保持软件一致性、降低用户学习成本，尤其是shell、Emacs文本编辑器、gcc编译套件、各种开发库等更让很多程序员爱不释手。但这个Hurd内核却进展缓慢，没什么起色。 1991年，一个叫Linus Torvalds的芬兰小伙子在鼓捣他老师的Minix系统(UNIX的变种版本，一般仅用在计算机教学中)之余，对其禁止用于商业目的很不满，决定要自己写成一个操作系统并允许在i386的机器上运行。这位天才hacker把自己的成果公布在互联网上，并逐渐吸引了世界范围内众多开发者的加入，使之不断完善，大家伙一商量，就按照Linus Torvalds的名字叫它“Linux”吧。Linux本身只是个操作系统的内核，支持POSIX标准，是一个UNIX-like系统内核，但完完全全是从零开始重写的代码，最重要的，它还是完全开源的自由软件。 这边FSF一看自己的Hurd还不知道什么时候能用呢，那边Linus Torvalds觉着GNU软件不赖，重新造轮子也累，于是众多厂商、机构、社区纷纷把GNU软件和Linux内核(以及其他的一些软件包)整合在一起组成一个完整的操作系统发行版，FSF表示没什么意见，只是坚持要求全称应该叫“GNU/Linux”，光叫Linux就把GNU的成果完全忽略掉了。GNU/Linux的诞生和发展，是一件足以影响计算机行业发展史的大事。 控制台、终端、shell概念 控制台、终端、shell是命令行界面（CLI）系统中极重要的几个概念。 控制台、终端、虚拟终端是一类输入输出设备的总称，拥有将用户指令输入给操作系统和将操作系统返回结果输出给用户的基本功能，电传打字机（teletypewriter，缩写为tty）是该类设备的具体实例。终端模拟器（Terminal Emulator）是一类应用程序，用来模拟终端设备的功能，未具体说明情况下，“终端”泛指真实终端设备或终端模拟器。 Shell是UNIX/Linux系统中最为重要的应用程序之一，负责解释执行用户指令，打印结果，和用户交互，进行着REPL（Read-Evaluate-Print Loop）。sh、bash、zsh、fish等都是Shell的具体实例。 Cygwin 计算机世界里存在各种各样的操作系统，目前通用操作系统有主流的三大类： UNIX，通用操作系统鼻祖，发展出特别多衍生系统； Windows，微软家根基，桌面市场霸主； GNU/Linux，UNIX近亲，有各种发行版如Ubuntu、CentOS等。 这些系统有各自的内核，出于系统稳定性考虑是不允许用户程序直接操作内核，同时也将内核开发和应用软件开发隔离开来，系统将必要的函数封装成库供应用软件调用，约定的规范即为应用软件接口(Application Program Interface，API)。API函数库是连接用户软件和系统内核桥梁，或者是“协议”，操作系统厂商写好函数库说明书，应用软件开发者不必关心其内部是如何实现的，用的时候对照着API手册查询就够了。 Cygwin是一个可原生运行于Windows系统上的POSIX兼容环境。 Cygwin就是在Windows中增加了一个中间层——兼容POSIX的模拟层，并在此基础上构建了大量Linux-like的软件工具。 Cygwin的优点 完备且相对轻量，普通用户不必安装整个Linux系统或虚拟机，就可以获得近乎一致的UNIX/Linux体验； Cygwin的程序运行与Windows互不干扰，高效的命令行工具与Windows图形界面各有所长、形成互补； 开源免费，安装卸载方便。 Cygwin的缺点 效率相对低； 未实现二进制文件级别的兼容； 与Windows互操作不足。 微软WSL 2016年，微软在Windows 10周年更新中，引入了新的子系统WSL（Windows Subsystem for Linux）。与SFU、Cygwin不同，WSL直接在二进制层面兼容Linux系统，Linux上的程序、函数库在WSL里都能运行，根本就省了“移植”的概念了。WSL迅速赢得众多用户青睐，特别是开发者，乃至被戏称“最佳Linux发行版”。能玩得动这个黑科技的，只有微软，因为Windows NT内核只有他才清楚。 WSL1在运行时处理Linux System Call，模拟Linux内核，但 Linux/UNIX 与Windows NT毕竟是两类内核，设计理念、设计标准等多方面差异甚大，无法实现完全对等模仿，WSL1和Cygwin都无法兼容所有Linux System Call，Wine也无法兼容所有Win32 API。这就造成有的程序无法在WSL1中运行，源码也无法在Cygwin中重新编译；同样有的程序无法在Wine中运行，源码无法在Linux/UNIX中重新编译。 也许是因为WSL1靠翻译System Call来模拟Linux内核的坑太大填不下去了，这种黑科技思路此次被微软完全抛弃，换成了虚拟机/容器的思路，仅仅是名字上延续了WSL，再也不是当初那个WSL了。WSL2引入了修改版的Linux内核，基于最新的 Linux 4.19，这也是Linux内核最新的长期支持版，新的内核经过了微软悉心改造，以便与Windows相配合，获得更好的用户体验。 由于使用了真正的Linux内核，意味着WSL2全面兼容Linux System Call，理论上能在GNU/Linux上运行的程序也都能在WSL2中不经修改直接运行。另外还带来一个好处是，可以更新Linux内核换取更高的效率和安全性，背靠微软这棵大树更新（微软背靠Linux基金会大树）。 视频资料：RevolutionOS, The Code (2001) (Linux Documentary). 安装WSL 2 (Windows Subsystem for Linux)WSL(Windows Subsystem for Linux) 是 Windows 系统中的一个子系统，在这个子系统上可以运行 Linux 操作系统。 WSL：最早发布的 WSL 并不是一个真正的 Linux 操作系统，仅仅是 Linux 应用程序与 Windows 操作系统之间的一个适配层。在这个适配层之上，可以运行 Linux 应用程序，有点类似于以前的 cygwin 的方式。 WSL 2：WSL 2 是适用于 Linux 的 Windows 子系统体系结构的一个新版本，它是对基础体系结构的一次重大改造。它使用虚拟化技术和 Linux 内核来实现其新功能。相对于 Virtual Box、VMWare 来说，WSL 2 提供更全面的兼容性、与 Windows 系统的互操作性更好、运行速度更快、占用系统资源更少。 安装先决条件： Windows 10 2020年5月(2004) 版, Windows 10 2019年5月(1903) 版，或者 Windows 10 2019年11月(1909) 版； 一台支持 Hyper-V 虚拟化的计算机。 以管理员身份打开 PowerShell，输入 1dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart 以启用 WSL。接着输入 1dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart 以启用虚拟平台，显示效果如下 查看 WSL 版本 下载 Linux 内核更新包 将 WSL 2 设置为默认 1wsl --set-default-version 2 需要注意的是，若在设置 WSL 2 为默认时一直不成功，尝试执行下面代码以开启 Windows 中的 Hyper-V 服务 1bcdedit /set hypervisorlaunchtype auto 注：打开 VMware 虚拟机需要关闭 Windows 中的 Hyper-V 服务（如下图）；开启 WSL 2 和 Docker 需要重新开启改服务。 打开 Microsoft Store 安装 Ubuntu 系统 为 Ubuntu 创建用户名密码 创建成功 设置 root 密码 参考 https://docs.microsoft.com/zh-cn/windows/wsl/install-manual https://www.cnblogs.com/guojikun/p/15092696.html 其它 Windows NT：是Windows系统的内核。市面上发行版的Windows系统都是基于NT各种版本内核开发的。例如WinXP是根据NT 5.X 开发的；Win7是根据NT 6.X开发的；Win10是根据NT 10.X开发的。 沙盒：Win10新增的Windows沙盒是一种安全机制，为执行中的程序提供的隔离环境，独立于主机运行。通常作为一些来源不可信的应用程序提供实验之用。沙盒是临时的，关闭后，将删除所有软件和文件以及状态。 每次打开应用程序时，都会获得沙盒的全新的实例。安装在主机上的软件和应用程序不会直接在沙盒中提供。 沙盒与虚拟机的区别： 当沙盒中的应用程序退出后，其所做的更改会被丢弃；而当虚拟机退出后，其所做更改将会被保存下来。 沙盒中的application和本机中其他application共享机器的硬件资源；而虚拟机在安装时需要为其指定内存和CPU且虚拟机不和本机中其他application共享硬件资源。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux 发展历程</tag>
        <tag>WSL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NAS搭建]]></title>
    <url>%2F2021%2F12%2F29%2FNAS%2F</url>
    <content type="text"><![CDATA[树莓派2B自买来就吃灰，打算将其改造成为NAS，搭建过程纪录如下。 NAS 搭建视频教程： up主：张小七先生 https://post.smzdm.com/p/a4wmxw98/ OMV视频教程： up主：张小七先生 up主：谈笑有Herald 内网穿透免费：ZeroTier 收费：蒲公英 docker教程及容器推荐Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。 容器及教程推荐： transmission：种子下载器 国外种子搜索网站：https://thepiratebay.org/index.html, https://1337x.proxyninja.org/； 国内种子搜索网站：http://btbtt14.com/； 学术课程种子搜索：https://academictorrents.com/； WebDAV服务：Linux/Win/OMV5 安装WebDAV服务； gitea：代码管理，类似于Github，gitea官网； trilium notes：超级牛的笔记app，教程见官方Wiki、Trilium：超高自由度的个人知识库－基础篇、使用 Trilium 构建个人知识库、Trilium 修改数据存储目录； calibreWeb：在线图书馆； Docker课程：Mosh Hamedani. 官网 其它课程：Git 课程，Python 课程. 树莓派2B安装 OpenMediaVault记录一下树莓派2B安装 OpenMediaVault 的踩坑过程。 直接刷 OMV 系统由于 OMV 基于 Debian 系统开发，考虑直接在树莓派中安装 OMV 系统。安装过程参考教程。出现的问题： 官方下载中已经不提供 Raspberry 版本的 OMV 系统，需要从教程中提供的网盘中下载镜像文件； 教程中提供的镜像 OMV 版本过低，对 docker 支持较差。 为了方便后续折腾，放弃该方案，转而考虑在官方 Raspbian 系统中安装 OMV。 Raspbian 系统中安装 OMV安装准备： 一张16GB SD卡、网线、键盘； SD卡格式化工具 SD Memory Card Formatter； 镜像烧录工具 Win32DiskImager； Raspbian系统安装： 下载32 位 Lite 版 Raspbian 镜像，需要注意的是，不要下载最新版的镜像，这会导致后面安装 OMV 时产生 package conflicts，故下载raspbian_lite-2019-09-30； 格式化 SD 卡，烧录 Raspbian lite 系统，并在根目录（/boot）下新建一个空文件 ssh 来开启 ssh 功能； 网线一端插在路由器上一端插在树莓派上，链接好键盘，上电； 在路由器后台获得树莓派 IP 地址，ssh 登陆树莓派； 默认账号 pi 密码 raspberry，使用命令 passwd 更改密码； 安装 OMV 系统 将Raspbian 上的源更改为清华的源 使用 sudo nano 打开 /etc/apt/sources.list，用下面代码替代原始代码 123deb http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main non-free contrib rpideb-src http://mirrors.tuna.tsinghua.edu.cn/raspbian/raspbian/ buster main non-free contrib rpi 使用 sudo nano 打开 /etc/apt/sources.list.d/raspi.list，用下面代码替代原始代码 1deb http://mirrors.tuna.tsinghua.edu.cn/raspberrypi/ buster main ui 更新 Linux 软件列表并重启树莓派 12345sudo apt update &amp;&amp; sudo apt -y upgrade sudo rm -f /etc/systemd/network/99-default.linksudo reboot 安装 OMV（github源可能会被墙，这里使用国内源） 1wget -O - https://cdn.jsdelivr.net/gh/OpenMediaVault-Plugi n-Developers/installScript@master/install | sudo bash 安装OMV 的过程比较久，耐心等待。 安装完成后树莓派的 IP 可能会发生变化，重新找到树莓派 IP 并将其复制到浏览器中即可看到 OMV 的登陆界面 默认帐号 admin 密码 openmediavault。 参考 https://shumeipai.nxez.com/download https://shumeipai.nxez.com/2018/01/10/raspberry-pi-nas-openmediavault-installation.html https://zhuanlan.zhihu.com/p/263836823 https://www.bilibili.com/video/BV16y4y1B7rF 遇到的问题安装 transmission 时在 log 中发现 docker 与 libseccomp2 版本冲突 解决方法：升级 libseccomp2； 参考：https://blog.samcater.com/fix-workaround-rpi4-docker-libseccomp2-docker-20/ 配置 trilium notes 时出错配置文件如下123456789101112version: &apos;2.1&apos;services: trilium: image: zadam/trilium container_name: trilium restart: always environment: - TRILIUM_DATA_DIR=/data ports: - &quot;yourport:8080&quot; volumes: - /yourdir:/data 遇到报错1Error: EACCES: permission denied, mkdir &apos;/data/log&apos; 解决方法：赋予 volume 映射的文件夹权限 1chmod 777 /yourdir 之后就能在 /yourdir 下看到 trilium 的.db文件和log。 参考：https://github.com/zadam/trilium/issues/1960]]></content>
      <categories>
        <category>NAS</category>
      </categories>
      <tags>
        <tag>OpenMediaVault</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信号检测与估计--3]]></title>
    <url>%2F2021%2F11%2F20%2F%E4%BF%A1%E5%8F%B7%E6%A3%80%E6%B5%8B%E4%B8%8E%E4%BC%B0%E8%AE%A1--3%2F</url>
    <content type="text"><![CDATA[整理了赵树杰，赵建勋老师的《信号检测与估计》中的内容。第三篇整理信号滤波问题。 信号滤波在信号估计中，我们假定被估计量的参量不随时间变化，属于静态估计。在实际问题中，如信号处理、图像处理、雷达目标跟踪、模式识别等，还需要对随时间变化的参量进行估计，这就是信号的波形估计，又称滤波理论。笼统地讲，滤波理论就是考虑如何设计滤波器尽可能抑制噪声，而把有用的信息提取出来。 几种基本的信号波形估计为：滤波、预测和平滑。由观测 $x(t)$ 得到 $\hat{s}(t)$ 的过程称为滤波；由观测 $x(t)$ 得到 $\hat{s}(t+a)$ 的过程称为预测（外推）；由观测 $x(t)$ 得到 $\hat{s}(t-a)$ 的过程称为平滑（内插）。 信号波形估计一般采用线性最优估计，例如维纳滤波和卡尔曼滤波。 维纳滤波设观测方程为 x(t) = s(t) + n(t), \quad 0\leq t\leq T.最佳线性滤波问题就是根据观测信号 $x(t)$，按照线性最小均方误差准则，对 $g(t)$ 进行估计，以获得估计波形 $\hat{g}(t)$。 进一步假设，$x(t)$ 和 $g(t)$ 都是零均值的平稳随机过程，而且二者是联合平稳的。假设估计 $\hat{g}(t)$ 是某个线性时不变系统对观测值 $x(t)$ 的响应，并考虑因果系统，则维纳滤波问题即求解最小均方误差下的系统函数 $h(t)$ \hat{g}(t) = \int^t_{-\infty }h(t-u)x(u)du.由线性最小均方误差估计的正交性原理 E\left[\left(g(t)-\int^t_{-\infty }h(t-\tau)x(u)du\right)x(\tau)\right] = 0, \quad -\infty]]></content>
      <categories>
        <category>Radar</category>
      </categories>
      <tags>
        <tag>信号滤波</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信号检测与估计--2]]></title>
    <url>%2F2021%2F11%2F20%2F%E4%BF%A1%E5%8F%B7%E6%A3%80%E6%B5%8B%E4%B8%8E%E4%BC%B0%E8%AE%A1--2%2F</url>
    <content type="text"><![CDATA[整理了赵树杰，赵建勋老师的《信号检测与估计》中的内容。第二篇整理信号估计问题。 信号估计研究在噪声干扰背景中，如何通过观测构造待估计参量的最佳估计量问题。 随机参量的贝叶斯估计 问题描述 在 $ p (\theta) $ 已知，选定代价函数 $ c(\theta - \hat{\theta }) $ 条件下，根据观测构造参量 $\theta$ 的最佳估计量 $ \hat{\theta}$，使得平均代价 $C$ 最小。 其中， C = \int^{\infty }_{-\infty } \int^{\infty }_{-\infty } c ( \theta - \hat{\theta )} p ( x, \theta ) d x d \theta .事实上，只需要使得条件平均代价 $ C(\hat{\theta }|x) $ 最小即可。其中 C(\hat{\theta }|x): = \int^{\infty }_{-\infty } c ( \theta - \hat{\theta )} p (\theta|x) d \theta . 基本方法 当 $ c ( \theta - \hat{\theta } ) = ( \theta - \hat{\theta } ) ^2 $ 时，称为最小均方误差估计。将 $ C(\hat{\theta }|x) $ 对 $ \hat{\theta }$ 求偏导并等于零，可得 \hat{\theta}_{mse} = \int^{\infty }_{-\infty } \theta p ( \theta | x ) d \theta,故又称条件均值估计。 当 $ c ( \theta - \hat{\theta } ) = |\theta - \hat{\theta }|$ 时，称为条件中值估计。将 $ C(\hat{\theta }|x) $ 对 $ \hat{\theta }$ 求偏导并等于零，可得 \int^{\hat{\theta }_{med}}_{-\infty } p ( \theta | x ) d \theta = \int^{\infty }_{\hat{\theta }_{med}} p ( \theta | x ) d \theta,故又称条件中位数估计。 当 $ c ( \theta - \hat{\theta } ) = 1(|\theta - \hat{\theta }|\geq \frac{\Delta }{2}), 0(|\theta - \hat{\theta }|&lt; \frac{\Delta }{2}))$ 时，称为最大后验估计。对于足够小的 $ \Delta $，为使条件平均代价最小，应选择 $ \hat{\theta }_{map}$ 使其处于 $p ( \theta | x ) $ 最大值的位置，即最大后验概率。 注：贝叶斯估计需要知道 $x$ 与 $\theta$ 的先验知识，并求出后验概率 $ p ( \theta | x ) $，这通常不易求得。 随机参量的线性最小均方误差估计贝叶斯估计需要知道 $x$ 和 $\theta$ 的先验知识，当我们只知道前二阶矩时，可以采用线性最小均方误差估计。 问题描述 假设观测模型是线性的 x = H \theta + n , 其中，$ H $ 是已知的观测系数矩阵，$ n$ 是观测噪声。假设估计量是观测的线性函数 \hat{\theta }_{lmse} = a + bx,求使得均方误差 $ E[(\theta - \hat{\theta })^T(\theta - \hat{\theta }) ] $ 最小的系数 $a$ 和 $b$。 基本方法 将均方误差函数分别对系数 $a$ 和 $b$ 求偏导并令其等于零。解得 \hat{\theta }_{lmse} = \mu _{\theta }+ C_{\theta x}C_x ^{-1} (x - \mu _x ), 其中，$ C_x = E[(x-E[x])(x-E[x])^T]$，$ C_{\theta x} = E[(x - E[x])(\theta - E[\theta ])^T]$。 性质 正交性原理 定理（正交性原理）估计误差与观测是正交的，即 E[(\theta - \hat{\theta }_{lmse})x^T] = 0. 无偏性：$ E[\hat{\theta }_{lmse}] = \mu _\theta $。 递推估计 由正交性原理可以根据第 $k$ 次观测 $ x _k $ 与其在 前 $(k-1)$ 次观测的投影之差 $ x _k - H _k \hat{\theta }_{k-1} $ 构造估计的修正项 $ \Delta \theta _k $ 来更新估计 $ \hat{\theta }_k = \hat{\theta }_{k-1} + \Delta \theta _k $。递推过程为 \hat{\theta }_k = \hat{\theta }_{k-1} + K _k ( x _k - H _k \hat{\theta }_{k-1} )其中，$ K_k $ 称为修正增益矩阵 K _k = M_{k-1}H^T _k (Hlk M_{k-1}H_k ^T + C_{n _k } )^{-1},其中，$ M_k $ 即均方误差阵 $ E[(\theta - \hat{\theta })(\theta - \hat{\theta })^T ] $，其迭代过程为 M _k = (I - K _k H _k )M_{k-1}.初值 $ \theta _0 $ 一般选取 $ \mu _\theta $，$ M _0 $ 选取 $ C _\theta $。 注：线性最小均方误差估计只需要知道 $x$ 和 $\theta$ 的前二阶矩，因此在实际中应用广泛；正交性原理是信号最佳线性滤波和估计算法的基础，在随机信号处理中有着重要地位。 非随机参量的最大似然估计对于非随机的参量，即 $ p(\theta ) = \delta (\theta - \theta_0 ) $ ，由贝叶斯公式 p(\theta |x) \sim p(x|\theta) p(\theta)可以通过最大化似然函数来得到最大后验估计。 最大似然估计可通过求解如下最大似然方程得到。 \frac{\partial p(x| \theta )}{\partial \theta }|_{\theta = \hat{\theta }_{ml}} = 0. 注：似然函数易于由观测模型得到，故有很好的实用性。 估计量的评价在按照某种准则获得估计量后，通常要对估计量的质量进行评价，一般研究估计量的无偏性、有效性、一致性和充分性。 无偏性：（非随机参量）$ E[\hat{\theta }]= \int^{\infty }_{-\infty } \hat{\theta } p(x| \theta ) d x = \theta $；（随机参量）$E[\hat{\theta }] = \int^{\infty }_{-\infty }\int^{\infty }_{-\infty } \hat{\theta } p(x,\theta ) d x d\theta = E[\theta ]$。 充分性：若有 $ p(x| \theta ) = g(\hat{\theta }(x) |\theta)h (x) , \quad h (x) \geq 0 $ 成立，则称 $ \hat{\theta } $ 是充分估计量。 有效性：均方误差达到克拉美－罗界的无偏估计。 克拉美－罗界：无偏估计均方误差的下界 （非随机参量）$E[(\theta - \hat{\theta })^2 ]\geq \frac{1}{-E[\frac{\partial ^2 \ln p(x| \theta )}{\partial \theta ^2 } ]} $，当且仅当 $x$ 和 $\theta$ 满足 $\frac{\partial \ln p(x| \theta )}{\partial \theta } = (\theta - \hat{\theta }) k (\theta) $ 时取等。 （非随机参量）$E[(\theta - \hat{\theta })^2 ]\geq \frac{1}{-E[\frac{\partial ^2 \ln p(x, \theta )}{\partial \theta ^2 } ]} $，当且仅当 $x$ 和 $\theta$ 满足 $\frac{\partial \ln p(x, \theta )}{\partial \theta } = (\theta - \hat{\theta }) k $ 时取等。 注：有效估计量必是充分估计量。对于非随机参参量，若其无偏有效估计存在，则它一定是最大似然估计；但反过来最大似然估计不一定是无偏、有效的。对于随机参参量，若其无偏有效估计存在，则它一定是最大后验估计；但反过来不一定。 最小二乘估计假设被估计量信号模型为 $ s (\theta) $，观测为 $ x $。最小二乘估计寻求使得下式最小的估计量 $ \hat{\theta }_{ls}$ J(\hat{\theta }) = (x - s (\hat{\theta}) )^T(x - s (\hat{\theta}) ) . 注：最小二乘估计不需要任何先验知识，只需要估计量的观测模型即可，但由于没有统计假设，性能无法评价。 参考文献［1］赵树杰, 赵建勋. 信号检测与估计[M]. 北京：清华大学出版社(2005).]]></content>
      <categories>
        <category>Radar</category>
      </categories>
      <tags>
        <tag>信号估计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信号检测与估计--1]]></title>
    <url>%2F2021%2F11%2F20%2F%E4%BF%A1%E5%8F%B7%E6%A3%80%E6%B5%8B%E4%B8%8E%E4%BC%B0%E8%AE%A1--1%2F</url>
    <content type="text"><![CDATA[整理了赵树杰，赵建勋老师的《信号检测与估计》中的内容。第一篇整理信号检测问题。 信号检测研究在噪声干扰背景下，所关心信号（已知常数）属于哪种状态的最佳判决问题，所用的主要数学工具是假设检验理论。下面整理二元信号检测问题的贝叶斯准则和奈曼－皮尔逊准则。 贝叶斯准则 问题描述 假设信号有两种不同的观测模型，分别记为 $ H _0 $ 和 $ H _1 $，若假设 $ H _j $ 为真而判决 $ H _i $ 成立的代价为 $ c _{ij} $ ，设计使得判决付出的总平均代价 C := \sum_{j=0}^1 \sum_{i=0}^1 c_{ij} P(H_j )P(H_i |H_j ),最小的判决器。其中，$ c _{ij} $ 给定，$ P(H _j )$ 已知，$ P(H _i |H _j ) = \int_{R_i }p ( x | H _j ) d x $ 。 基本方法 根据 $C$ 的取值正负的特性，可以选择使 $ H _0 $ 成立的判决域 $ R _0 $ 为 \lambda (x) : = \frac{p(x|H _1)}{p(x|H _0)} < \eta : = \frac{P(H _0)(c_{10}- c_{00})}{P(H _1 )(c_{10}- c_{11})}$ \lambda (x) $ 称为似然比函数，$ \eta $ 称为似然比检测门限。 对上式进一步化简左端可变为$x$ 的最简函数 $ l (x) $ ，称为检验统计量，右端可化简为常数 $ \gamma $ ，称为检测门限。 例子 ［1，例3.3.1］ 假设 H_0 : x (t) = n (t), \quad H _1 : x (t) = A + n (t) , \quad 0\leq t \leq T,其中，$A$ 已知，$ n (t) $ 是均值为零、方差为 $ \sigma _n ^2 $ 的高斯噪声。在 0～T 内 $N$ 次采样后得到 H_0 : x_k = n_k , \quad H _1 : x_k = A + n_k, \quad k = 1,2,\cdots N. 在两种假设下，由观测的独立性，$N$ 维观测 $ x = (x _1 , \cdots,x _N ) $ 的概率密度函数为 p ( x | H _0 ) = \prod_{k=1}^N p ( x _k |H _0) = \left(\frac{1}{2\pi \sigma _n ^2 } \right)^{\frac{N}{2} }\exp\left(- \sum_{k=1}^N \frac{x _k ^2 }{2\sigma _n ^2 } \right), p ( x | H _1 ) = \prod_{k=1}^N p ( x _k |H _1) = \left(\frac{1}{2\pi \sigma _n ^2 } \right)^{\frac{N}{2} }\exp\left(- \sum_{k=1}^N \frac{( x _k- A )^2 }{2\sigma _n ^2 } \right),判决表达式为（接收 $H_0 $） l (x) : = \frac{1}{N}\sum_{k=1}^N x _k < \gamma : = \frac{\sigma ^2 _n }{NA}\ln \eta + \frac{A}{2},其中，$ \eta $ 为已知的似然比检测门限。 由于 $ x$ 是高斯的，因此 $ l (x) $ 也是高斯的，易求出 E[l | H _0 ]=0, \quad E[l| H_1 ] = A. Var(l|H_0 ) = \frac{\sigma_n ^2 }{N}, \quad Var(l|H_1 ) = \frac{\sigma_n ^2 }{N}.于是根据判决表示式， P(H_1 | H_0 ) = \int_\gamma ^{\infty }p ( l| H _0 ) d l = Q[\ln \eta /d + \frac{d}{2} ] P(H _1 | H _1 )= \int_\gamma ^{\infty }p ( l| H _1 ) d l = Q[\ln \eta /d - \frac{d}{2} ] = Q[Q^{-1}[P(H _1 | H _0 )] - d],其中，$ d : = \frac{NA^2 }{\sigma_n ^2 }$ 称作功率信噪比，$ Q[u] $ 是标准正态分布从 $u$ 到正无穷的积分。 注：记 $P_F : = P(H_1 | H_0 ) $ ，$P_D : = P(H_1 | H_1 ) $，则对于给定 $ P_F $，$P_D$ 随 $d$ 单调增加；常用接收机工作特性描述信号检验的性能，即反映 $ P_F$、$P_D$、$\eta $ 和 $d$ 之间的关系；信噪比 $d$ 在信号检测中占有非常重要的地位，是接收机的主要技术指标之一。 推论 当 $ c_{01}=c_{10}=1$，$c_{00}=c_{11}=0$ 时贝叶斯准则就成为最小平均错误概率准则； 当 $ c_{10}-c_{00} = c_{01}-c_{11} $ 时贝叶斯准则就成为最大后验概率准则； 奈曼－皮尔逊准则 问题描述 在一些雷达信号检测问题中，我们既不能预先知道先验 $ P(H _j) $ 又不能知道代价因子 $ c _{ij} $，于是人们提出在虚警率 $ P(H _1 | H _0) = \alpha $ 的约束下， 使得正确判决 $ P(H _1 | H _1 ) $ 最大的准则。 基本方法 使用Lagrange乘子法，结合目标函数的正负性分析，选择使 $ H _0 $ 成立的判决域为 \lambda (x) = \frac{p(x|H _1)}{p(x|H _0)} < \mu 其中，$ \mu $ 为乘子，由 $ \alpha = \int_\mu ^{\infty } p ( \lambda | H _0 ) d \lambda $ 确定。 注：如果在贝叶斯准则中令 $ P(H _1 )(c_{01}-c_{11}) = 1$，$ P ( H _0 ) ( c_{10}-c_{00}) = \mu $ ，则贝叶斯准则成为奈曼－皮尔逊准则。 参量信号的检测在上面两种检测中，我们假设两种信号模型中信号是确知信号，在实际应用场景中信号一般会带有未知参数 $ \theta $ ，此时的信号检测称作参量信号的统计检测。参量信号检测的核心就是消除参数 $ \theta $ 的影响，将问题转化为确知信号的检测问题上。 广义似然比函数法若参数是非随机的，此时观测 $x$ 的概率密度函数 $ p( x | \theta ; H_0 ) $ 与 $ p ( x| \theta ; H_1 ) $ 与 $ \theta $ 有关，可以先利用最大似然估计方法求出 $ \hat{\theta } $ 再用确知信号的方法进行检测。 贝叶斯方法若参数是随机的，且先验 $ p (\theta) $ 已知，则可以利用 $ p(x|H_0 ) = \int_{\Theta} p(x| \theta ; H_0) p(\theta ) d \theta $ 的方法消除参数 $\theta$ 的影响。 信号的序列检测由于功率信噪比与观测次数正相关，功率信噪比又与判决的准确性正相关，于是如果可以边观测边检测则可大大提高检测效率，这样的检测方式称作信号的序列检测，详见 ［1，3.8节］。 信号波形检测在前面的信号检测中，信号一般是一个固定或含参常数 $A$ ；而在信号波形检测中，信号一般是时间的函数 $ s (t) $ 。 信号波形检测的核心是对观测 $ x (t) $ 和信号 $ s (t) $ 用正交基展开，而后用信号检测的手段设计检测系统。为了解决展开系数互相关的问题，一般采用卡亨南－洛维展开式。特别地，在白噪声情况下，任意正交函数集对平稳随机过程 $ x(t) $ 进行展开的系数都是互不相关的。因此，在接下来的讨论中考虑零均值、功率谱密度为 $ \frac{N_0 }{2} $ 的高斯白噪声 $ n (t)$。 一般二元信号波形检测 信号模型 H _0 : x (t) = s _0 (t) + n (t) , \quad H _1 : x (t) = s _1 (t) + n (t) , \quad 0 \leq t \leq T. 判决表示 用正交函数集对 $ x (t) $、$ s_0 (t) $、$s_1 (t) $、$n (t) $ 进行展开，并运用似然比检验手段得到 \ln \lambda (x_N ): = \frac{2}{N_0 } \sum_{k=1}^N x _k s_{1k} - \frac{2}{N_0 } \sum_{k=1}^N x _k s_{0k} - \frac{1}{N_0 } \sum_{k=1}^N s_{1k}^2 + \frac{1}{N_0 }\sum_{k=1}^N s_{0k}^2 < \ln \eta , \quad H_0\text{( 成立)}.令 $ N \rightarrow \infty $ 得 l (x(t) ): = \int_0 ^T x (t) s _1 (t) d t - \int _0 ^T x (t) s _0 (t) d t < \gamma : = \frac{N _0 }{2}\ln \eta + \frac{1}{2} (E_{s _1 }- E_{s _0 }) 性能分析 由定义 $ l (x(t) ) $ 是一个高斯随机变量，可以求得 E[l| H _0 ] = \rho \sqrt{E_{s _0}E_{s_1}}- E_{s_0},\quad Var(l|H _0 ) = \frac{N _0 }{2}E_{s_1} + \frac{N _0 }{2}E_{s_0} - N _0 \rho \sqrt{E_{s _0}E_{s_1}},其中，$ \rho : = \frac{1}{\sqrt{E_{s _0}E_{s_1}}} \int _0 ^T s _1 (t) s _0 (t) d t$ 为波形相关系数。类似地，可以求出 $ E[l| H_1 ] $ 和 $ Var(l|H_1 )$。综上，有 P _F : = P(H _1 | H _0 )= Q[\ln \eta /d + \frac{d}{2} ], \quad P _D : = P(H _1 | H _1 ) = Q[\ln \eta /d - \frac{d}{2} ] = Q[Q ^{-1} (P_F) - d],其中，偏移系数为 d ^2 = \frac{(E[l|H _1 ] - E[l|H _0 ])^2 }{Var(l|H _0 )}= \frac{N _0 }{2}(E_{s_1}+E_{s_0}-2 \rho\sqrt{E_{s _0}E_{s_1}}). 最佳波形设计信号的检测性能与偏移系数 $ d^2 $ 正相关。因此在高斯白噪声情况下，对于确知二元信号的波形检测，当两个信号设计成相反的信号时，即 $ s _0 (t) = -s _1 (t) $ 时，偏移系数 $ d^2 = \frac{8E _s }{N _0 } $ 最大，检测效果最好。 参量信号波形检测上面讨论了确知信号的波形检测问题。但在实际问题中，信号往往带有未知参数，例如信号的相位、振幅、频率、到达时间等。类似于参量信号的检测问题，参量信号波形检测的核心也是消除参数 $ \theta $ 的影响，常用的方法有贝叶斯方法（参数先验已知）和广义似然比函数方法（参数非随机），详见［1，4.6节］。 匹配滤波为了改善信噪比，信号接收机（检测系统）通常要求按照匹配滤波器来设计。 问题描述 接收机一般由一个线性滤波器和一个判决器串联而成，在输入信号功率信噪比一定的情况下，设计线性滤波器使得输出信号的功率信噪比最大。 基本方法 设待求滤波器为 $ H(\omega) $ ，设输入信号为 x (t) = s (t) + n (t) , 其中，$ s(t) $ 是确知信号，$ n (t) $ 是均值为零功率谱密度为 $ P _n (\omega) $ 的平稳噪声。设输出信号为 y (t) = s _o (t) + n _o (t),则 $ s_o (t) = IFT[H (\omega)S (\omega) ] $，$ P _{n _o }(\omega) = |H (\omega) |^2 P _n (\omega) $。 定义（滤波器的输出功率信噪比） SNR_o = \frac{s _o (t) \text{ 的峰值功率}}{n _o (t) \text{ 的平均功率}} = \frac{|s _o (t_0 ) |^2 }{\frac{1}{2\pi} \int^{\infty }_{-\infty }|H (\omega) |^2 P _n (\omega) d \omega } 利用 Cauchy-Schwarz 不等式可以得到 SNR _o \leq \frac{1}{2\pi} \int^{\infty }_{-\infty }\frac{|S (\omega)|^2 }{P _n (\omega) } d \omega ,取等当且仅当 H (\omega) = \frac{\alpha S^*(\omega)}{P _n (\omega)}e^{-j\omega t_0}.特别地，对于白噪声 $ n (t) $， $ P_n (\omega) = \frac{N_0 }{2} $，匹配滤波器的系统函数为 H (\omega) = kS^* (\omega) e^{-j \omega t_0 }, \quad h (t) = ks^*(t _0 - t ),最大输出功率信噪比为 SNR _o = \frac{1}{2\pi} \int^{\infty }_{-\infty }\frac{|S (\omega)|^2 }{P _n (\omega) } d \omega = \frac{2E _s }{N _0 }. 注：一般 $ t_0 $ 选择在输入信号 $ s (t) $ 的末尾时刻 $T$；在白噪声情况下，匹配滤波器的输出功率信噪比只与输入信号能量有关，与其波形无关；在白噪声情况下，$T$ 时刻匹配滤波器输出信号与相关器输出信号相等（可用于信号波形检测系统的构造）。 参考文献［1］赵树杰, 赵建勋. 信号检测与估计[M]. 北京：清华大学出版社(2005).]]></content>
      <categories>
        <category>Radar</category>
      </categories>
      <tags>
        <tag>信号检测</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信号检测与估计--0]]></title>
    <url>%2F2021%2F11%2F20%2F%E4%BF%A1%E5%8F%B7%E6%A3%80%E6%B5%8B%E4%B8%8E%E4%BC%B0%E8%AE%A1--0%2F</url>
    <content type="text"><![CDATA[整理了赵树杰，赵建勋老师的《信号检测与估计》中的内容。第零篇整理了假设检验中的数学基础和信号与系统中的基础。本文档未完善，后面继续补充。 数学基础 随机变量的原点矩：$r^{(m)}_x := E[x^m] = \int_X x^m p(x)dx$，特别地，均值 $\mu_x := r^{(1)}_x$. 随机变量的中心矩：$c^{(m)}_x:= E[(x-\mu_x)^m]$，特别地，方差 $\sigma^2_x := c^{(2)}_x $. 随机变量的函数的均值：若随机变量 $x$ 的概率密度为 $p(x)$ 则 $y = g(x)$ 的均值为 $E[y] = \int_X g(x)p(x) dx$. 常见分布 均匀分布 Gauss 分布 Rayleigh 分布 随机变量独立性：若 $ p(x,y) = p(x)p(y) $，则随机变量 $x$ 和 $y$ 独立. 随机变量的特征函数：$ G_x (\omega) := E[\exp(j \omega x)]$，即概率密度函数 $ p(x) $ 的傅立叶变换；特别地， G _x (\omega) = \sum_{m=0}^\infty \frac{(j \omega )^m }{m !}r^{(m)}_x. 随机过程的均值：$ \mu _x (t) : = E[x (t) ] = \int_X x p ( x; t ) d x$ . 随机过程的方差：$ \sigma ^2 (x) (t) : = E[(x (t) - \mu _x (t) ) ^2 ] = E[x ^2 (t) ] - \mu ^2 _x (t) $ . 随机过程的自相关函数：$ r _x ( t _j, t _k ) : = E[x (t_j ) x (t_k ) ]= \int \int x _j x _k p ( x _j , x _k ;t _j , t _k ) d x _j d x _k$ . 随机过程的自协方差函数：$ c _x ( t _j , t _k ) : = E[(x ( t _j ) - \mu ( t _j ) ) ( x ( t _k ) - \mu _x ( t _k ) )]$ . 随机过程的互相关函数：$ r_{xy} ( t _j , t _k ) : = E[x ( t _j ) y ( t _k ) ]$ . 随机过程互协方差函数：$ c_{xy}( t _j , t _k ) : = E[( x ( t _j ) - \mu _x ( t _j ) ) ( y ( t _k ) - \mu _y ( t _k ) ) ]$ . 随机过程的（广义）平稳性：(1) $ E[x (t) ] = \mu _x $ ; (2) $ E[x ( t _j ) x ( t _k ) ] = r _x (t _k - t _j ): = r _x (\tau) $ . 相互正交的随机过程：$ r _x ( t _j , t _k ) = 0, j\neq k $ . 互不相关的随机过程：$ c _x ( t _j ,t _k ) = 0,j \neq k $ 或等价地 $ r _x ( t _j , t _k ) = \mu _x ( t _j ) \mu _x ( t _k ) $ . 相互独立的随机过程：$ p ( x (t_1),x ( t _2 ),\cdots, x ( t _N ) ) = p ( x ( t _1 ) ) p ( x ( t _2 )) \cdots p(x (t _N )) $ ，特别地，独立可推出不相关，但反过来只有在高斯分布时才成立. 傅立叶（逆）变换： X (\omega) = FT[x (t) ] = \int^{\infty }_{-\infty }x (t) e^{- j \omega t} d t, x (t) = IFT[X (\omega) ] = \frac{1}{2\pi } \int^{\infty }_{-\infty }X (\omega)e^{j \omega t} d \omega. 拉普拉斯变换: F(s) = \int^{\infty }_0 f(t)e^{-st}dt,\quad s\in \mathbb{C}.特别地，当$s$ 为纯虚数时，双边拉普拉斯变换就是傅立叶变换。 信号与系统基础 信号分类 能量信号：一个信号的能量是有限的，即 $E:=\int^{+\infty}_{-\infty } |x(t)| ^2 d t &lt; \infty$ . 功率信号：一个信号的功率是有限的，即 $P := \lim_{T\rightarrow\infty}\frac{1}{T} \int^{\frac{T}{2}}_{-\frac{T}{2}} |x (t) |^2 d t&lt;\infty $ . 注：一个信号不可能同时是能量信号和功率信号，但可以同时不是这两种信号；功率信号一般又可以分为周期信号和随机信号；能量信号和周期信号可以进行傅立叶变换，而随机信号不可以做傅立叶变换。 频谱：能量信号 $x (t) $ 的傅立叶变换 $F (\omega) $ . 能量谱密度：$ E(\omega) : = |F (\omega) | ^2 $，且有 $ E = \frac{1}{2\pi}\int^{+\infty }_{-\infty } E (\omega) d \omega $ 成立. 功率谱密度：$ P (\omega) : = \lim_{T \rightarrow \infty }\frac{1}{T} |F_T (\omega) | ^2 $ ，其中 $ F_T (\omega) $ 是 $x(t) $ 的截断函数的傅立叶变换. 性质： 平均功率$ P = \frac{1}{2\pi}\int^{+\infty }_{-\infty } P (\omega) d \omega $. 对于平稳随机信号 $ x (t) $ 由维纳－辛钦定理有 P_x (\omega) = \int ^{+\infty }_{-\infty } r _x (\tau) e^{- j\omega \tau }d \tau, \quad r_x (\tau) = \frac{1}{2\pi }\int^{+\infty }_{-\infty }P_x (\omega) e^{j\omega \tau }d\omega. 线性时不变系统性质： 输出 $ y (t) = (x * h) (t) $，其中，$ h (t) $ 是系统的单位脉冲响应。 如果输入是一个平稳随机过程，则其响应也是一个平稳随机过程。 系统响应 $y (t) $ 的功率谱密度与输入 $x (t) $ 的功率谱密度满足：$ P _y ( \omega ) = |H (\omega) | ^2 P _x (\omega) $ . 噪声 高斯噪声：根据中心极限定理，系统的各种杂波干扰可以在时域上用高斯过程描述. 白噪声：功率谱密度为 $ P _n (\omega) = \frac{N_0}{2} $，均值为零的平稳过程 $ n (t) $；或等价地，白噪声也可定义为均值为零、自相关函数为 $\delta $ 函数的平稳过程. 注：对于高斯白噪声，在不同时刻 $ t _k $ 时，$ n (t_k ) $ 是互不相关且相互独立的. 有色噪声：功率谱密度在频域上不是均匀分布的平稳过程. 窄带噪声： 高频限带噪声，即噪声的功率谱密度仅在高频 $\pm f_0$ 附近一个很窄的频率范围内存在。一般可以假设为 $ n (t) = n_R (t) \cos \omega_0 t - n_l (t) \sin \omega_0 t : = a_n (t) \cos(\omega_0 t + \theta_n (t) )$，其中 $ \theta_n (t_0) $ 一般服从均匀分布，$ a _n(t_0)$ 一般服从 Rayleigh 分布。 注：在通信、雷达等系统中，接收系统的输入噪声一般是宽带随机过程，而接收系统中的高频放大器、中频放大器通常是根据与有用信号 $ s (t) $ 相匹配的匹配滤波设计的，而 $ s (t) $ 的载波频率很高，信号带宽一般很窄，因此接收系统通常是个窄带系统。 信号调制：将信号 $ x (t) $ 与周期信号相乘后，将原有频谱搬移到新的位置。例如，$ y (t) = x (t) \cos(\omega _c t + \theta ) $ ，若限制 $ x (t) $ 的频谱在 $ \omega _0 $ 内，则调制后的频谱被限制在 $ \pm \omega _c $ 附近半径为 $ \omega _0 $ 的频率内。 信号加窗 信号采样 参考文献［1］赵树杰, 赵建勋. 信号检测与估计[M]. 北京：清华大学出版社(2005). ［2］Yarlagadda RR. Analog and digital signals and systems[M]. New York: Springer(2010).]]></content>
      <categories>
        <category>Radar</category>
      </categories>
      <tags>
        <tag>信号与系统基础</tag>
        <tag>假设检验基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[凸几何与最优传输]]></title>
    <url>%2F2021%2F11%2F14%2F%E5%87%B8%E5%87%A0%E4%BD%95%E4%B8%8E%E6%9C%80%E4%BC%98%E4%BC%A0%E8%BE%93%2F</url>
    <content type="text"><![CDATA[整理了顾险峰老师新作《最优传输理论与计算》中将凸几何与最优传输联系起来的过程。 凸几何Minkowski 问题假设 $S$ 是 $ \mathbb{R}^3 $ 中一个闭凸曲面，则它的 Gauss 映射是可逆的，记为 $ N_K: S \rightarrow \mathbb{S} ^2 $. 因此我们可以用 Gauss 映射来参数化曲面，记为 $ S(y)$ ，$ y=N_K (x) \in \mathbb{S} ^2 $. 响应的 Gauss 曲率表示为 $ K(y): = K(N_K ^{-1} (y)) $. 由 Gauss 映射的性质，我们有 \int_{\mathbb{S} ^2 }\frac{y}{K(y)} d A_{\mathbb{S}^2 }(y) = 0.事实上，由 Gauss 曲率和 Gauss 映射的关系可以得到 \begin{aligned} \int_{\mathbb{S} ^2 }\frac{y}{K(y)} d A_{\mathbb{S}^2 }(y) & = \int_S \frac{N_K(x)}{K(x)}\det(DN_K)(x)d A_S(x)\\ & = \int_S N_K(x)d A_S(x)\\ & = 0, \end{aligned}最后一个等号成立是由于法向量在闭曲面上积分为零（可用散度定理证明）。 ​ 定义 $ \mathbb{S}^2 $ 上的一个测度 $\nu$ 为 $ N_K $ 前推 $S$ 上的 Lebesgue 测度，即 $ d \nu := (N_K)_{\sharp}d A_S $. 于是凸曲面满足条件： \int_{\mathbb{S}^2 }y d \nu (y)= \int_{\mathbb{S} ^2 }\frac{y}{K(y)} d A_{\mathbb{S}^2 }(y) = 0.\tag{1}Minkowski 问题是上述过程的反命题，即 Minkowski 问题 给定 $ \mathbb{S}^2 $ 上的测度 $ \nu $ ，则是否存在闭曲面 $S$ 使得 (1) 式成立。 我们可以构造球面上的一个胞腔分解 $ \mathbb{S}^2 = \cup_{i=1} ^n W _i $，则对每个 $ W _i $ 计算向量 v _i = \int_{W _i }\frac{y}{K(y)} d A_{\mathbb{S}^2 }(y),令 $ A_i = |v _i | $，$ w _i = v _i /A _i $，则离散 Minkowski 问题可表述为 离散 Minkowski 问题 寻找闭凸多面体使得其第$i$ 个面的法向量等于 $ w _i $，面积等于 $A_i $. Alexandrov 问题Alexandrov 将离散 Minkowski 问题推广到无限凸多面体的情形。 定理（Alexandrov） 假设 $\Omega$ 是 $ \mathbb{R}^d $ 中的凸多面体，内部非空，$ p _1 , \cdots , p _n \subset \mathbb{R}^d $ 是 $n$ 个不同的点，$ A _i , \cdots A _n &gt;0 $ 满足 $\sum_{i=1}^n A _i = Vol(\Omega) $，则存在一个高度向量 $h$，使得凸多面体 $ P(h) $ 每个余维是1的面的投影与 $\Omega$ 交集的体积为 $ A_i $ 即 $ w _i (h) = Vol(W _i (h) \cap \Omega ) = A _i,i =1, \cdots n$. 满足上述条件的高度向量相差一个常数向量 $c$。 证明令 $ \mu $ 为定义在 $\Omega$ 上的 Lebesgue测度，令 $ \nu = \sum_{i=1}^n A _i \delta (y - p _i ) $，令传输代价为 $ c(x,y) = \frac{1}{2} |x - y | ^2 $ 则由 Brenier 定理，存在凸函数 $u : \Omega \rightarrow \mathbb{R} $，使得 $ \nabla u $ 是最优传输映射。此时 $u$ 定义了 $\Omega$ 的一个胞腔分解 $ W _i = (\nabla u ) ^{-1} (p _i ) $ 和高度向量 $h$ u (x) = \max_{1\leq i\leq n}\{\langle p _i ,x\rangle- h _i \}. 推广的 Alexandrov 问题 定理（推广 Alexandrov） 设 $\Omega$ 是 $\mathbb{R} ^d $ 上的一个紧凸区域，$ p _1 , \cdots , p _n \subset \mathbb{R}^d $ 是 $n$ 个不同的点，$ \sigma : \Omega \rightarrow \mathbb{R} $ 是一个密度函数。若 $ A _i , \cdots A _n &gt;0 $ 满足 $\sum_{i=1}^n A _i = \int_{\Omega}\sigma (x) d x $，则存在一个高度向量 $h$，使得 $ \int _{W _i (h) \cap \Omega} \sigma (x) d x = A _i , \forall i $. 满足上述条件的高度向量相差一个常数向量 $c$，并且高度向量 $h$ 是如下凸函数的最小值点 E (h) = \int_0 ^h \sum_{i = 1} ^n \left(\int_{W _i (h) \cap \Omega } \sigma (x) d x - A_i \right)d h _i,\tag{2}此凸函数定义在开凸集 $ \mathcal{H} := \left\{h \in \mathbb{R} ^n : \int_{W _i (h) \cap \Omega } \sigma (x) d x&gt;0, \forall i\right\}$. 如果密度函数 $\sigma$ 等于 1，则为经典的 Alexandrov 定理。可以使用 Brenier 最优传输定理证明上述定理，书中使用变分原理来证明该问题，这样做的好处是为数值计算过程带来便利。 使用变分法的前提是有以下命题 命题 设 $ \sigma : \Omega \rightarrow \mathbb{R} $ 是定义在紧凸集上的连续函数，$ p _1 , \cdots , p _n \subset \mathbb{R}^d $ 是 $n$ 个不同的点，且 $h\in \mathbb{R}^d$ 使得对任意 $i$ 都有 $ Vol(W _i (h) \cap \Omega ) &gt;0 $ 则 w _i (h) : = \int_{W _i (h) \cap \Omega } \sigma (x) d x是 $h$ 的可微函数。若 $ W _i (h) \cap \Omega $ 与 $ W _j (h) \cap \Omega $ 共用一个余维数为1的面 $ \Gamma _h (i,j) $ 则有 \frac{\partial w _i (h) }{\partial h _j }= - \frac{1}{|p _i - p _j |}\int_{\Gamma _h (i,j)}\sigma d A,\tag{3}否则，偏导数为零。特别地，我们有 \frac{\partial w _i (h) }{\partial h _j }= \frac{\partial w _j (h) }{\partial h _i }.若进一步有 $ \sum_{i=1}^n w _i (h) = const $，则 \frac{\partial w _i (h) }{\partial h _i }=-\sum_{j\neq i} \frac{\partial w _i (h) }{\partial h _j }. 有了以上命题，我们就可以用变分法来证明推广的 Alexandrov 问题。 命题（变分原理） 设 $X\subset \mathbb{R}^n $ 是一个单连通开集，$ A (x) : X \rightarrow \mathbb{R}^n $ 是一个光滑函数，满足对称条件 $ \frac{\partial A _i (x) }{\partial x _j } = \frac{\partial A _j (x) }{\partial x _i }$，则对任意给定常数 $B\in \mathbb{R}^n $，方程 $ A (x) = B $ 的解是以下函数的临界点 E (x) = \int _a ^x \sum_{i = 1}^n (A _i (s) - B _i )d s _i. 注：由对称性条件，上述积分是良定的。 最优传输问题最优传输映射 $ T :(\Omega , \mu ) \rightarrow (D, \nu ) $，其中 $\Omega$ 和 $D$ 是 $ \mathbb{R}^d $ 中的一个紧凸域，$\mu$ 有连续密度 $ d \mu = f (x) d x $，$\nu$ 有连续密度 $ d \nu = g (x) d x $. 总质量 $ \int_\Omega f (x) d x = \int _D g (x) d x $. 考虑 $ L ^2 $ 成本函数 $ c(x,y) = \frac{1}{2} |x-y| ^2 $ 。由 Brenier 定理，最优传输映射为 $ T(x) = \nabla u (x) $，$u$ 为凸函数。 在计算中，我们离散目标域和测度 $ (D, \nu ) $，即用 Dirac 测度 $ \nu ^{(k)} $ 来逼近 $\nu$，之后求解半离散最优传输问题得到 $ u^{(k)} $。由于 Monge-Ampere 方程的稳定性，$u^{(k)}$ 收敛到光滑解 $u$。我们对 $D$ 均匀采样，得到 $ \{y _i , \cdots , y _n \} $，计算由样本诱导的 Voronoi 图 W _i : = \left\{y \in \mathbb{R}^d : \frac{1}{2} |y - y _i |^2 \leq \frac{1}{2} |y - y _j |^2 , \forall j\right\}, \quad \mathbb{R}^d = \bigcup_{i = 1}^nW _i .考虑 Dirac 测度 \sum_{i = 1} ^n = \nu _i \delta ( y - y _i ) , \quad \nu _i : = \int_{W _i \cap D} g (y) d y.最优传输问题想找到 Kantorovich 势能 $ \varphi: \{y _i , \cdots , y _n \} \rightarrow \mathbb{R} $，来最大化 \max _\varphi \left\{F (\varphi ): = \int _X \varphi^c (x) d \mu (x) + \int _Y \varphi (y) d \nu (y) \right\},其中， $ \varphi ^c $ 为 $ \varphi $ 的 $c$-变换 \varphi ^c (x) = \min_{i=1} ^n \{c ( x, y _i ) - \varphi _i \}. 定义（$c$-Voronoi 胞腔分解） W_{\varphi } (i) : = \left\{x \in X: c ( x, y _i ) - \varphi _i \leq c ( x , y _j ) - \varphi _j , \forall j\right\}, \quad X = \bigcup_{i = 1}^n W _\varphi (i) . 则 $ \varphi ^c $ 可以写为 \varphi ^c (x) = c ( x, y _i ) - \varphi _i , \quad \forall x \in W _\phi (i) .于是，能量泛函 $ F(\varphi ) $ 可写作 F(\varphi ) = \sum_{i = 1} ^n ( \nu_i - \mu ( W _\varphi (i) ) ) \varphi _i + \sum_{i = 1} ^n \int_{W _\varphi (i) }c ( x, y _i ) f (x) d x.\tag{4}通过计算（非平凡）可以得到如下半离散最优传输定理 定理（半离散最优传输） 符号同上，给定一个 $ C ^2 $ 的传输代价 $ c: X \times Y \rightarrow \mathbb{R} $，半离散最优传输问题的 Kantorovich 对偶泛函定义如上，则其一阶偏导为 \frac{\partial F (\varphi )}{\partial \varphi _i }= \nu _i - \mu ( W _\varphi (i) ) ,二阶偏导数为 \frac{\partial ^2 F (\varphi )}{\partial \varphi _j \partial \varphi _i } = \int_{W _\varphi (i) \cap W _\varphi (j) }\frac{f (x) }{|\nabla_x c ( x,y _i ) - \nabla _x c ( x, y _j ) |} d \mathcal{H} ^{d-1}(x).\tag{5}更进一步，$ F (\varphi) $ 在空间 $ \{\varphi : \sum_{i = 1} ^n \varphi _i = 1\}$ 中是严格凹的。 通过比较（2）式与（4）式，（3）式与（5）式，我们发现求解半离散最优传输问题与求解 Alexandrov 问题一致，这就将凸几何中的问题与最优传输问题联系了起来。 进一步地，由于$ F(\varphi) $ 是凸函数，且有显式的一阶、二阶偏导数，因此可以用 Newton 法或者梯度下降的方法进行求解。不过需要注意的是，迭代求解的过程需要不断更新 $c$-Voronoi 胞腔分解，这将是一个难点。 综上所述，我们建立了如下关系 graph LR A[Minkowski问题] -->|推广| B[推广的Alexandrov问题] B ---|等价| C(半离散最优传输问题) C -->|逼近| D(最优传输问题)]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>凸几何</tag>
        <tag>最优传输</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[科研基本知识：国家人才计划、学术索引、协会及出版商]]></title>
    <url>%2F2021%2F07%2F22%2F%E4%BA%BA%E6%89%8D%E8%AE%A1%E5%88%92%E5%8F%8A%E6%9C%9F%E5%88%8A%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[本文介绍了国家人才计划／项目有哪些，SCI、EI、核心期刊都是什么，以及协会和出版商的出版流程。 国家人才计划／项目梳理国家在不同渠道下的人才计划。 一、国家自然科学基金人才项目 青年科学基金项目：3年，20－25万，年龄不超过男 35 女 40。 地区科学基金项目：4年，40万，无。 优秀青年科学基金项目：3年，130万，年龄不超过男 38 女 40。 国家杰出青年科学基金项目：5年，245－350万，年龄不超过 45。 创新研究群体项目：6年，735－1050万，年龄不超过 55。 二、中组部人才项目 千人计划：100万／人，年龄不超过 55，应在海外取得博士学位。 青年千人计划：50万／人，年龄不超过 40，在海外知名高校、科研机构或企业有正式职位。 万人计划（人社部）： 杰出人才：100万／人，中青年，具有成长为世界级科学家的潜力； 领军人才：3年80万－100万／人，年龄不超过 50，研究工作具有重大创新性和发展前景； 青年拔尖人才：（科研经费）3年120万－240万／人，年龄不超过 35。 三、科技部 “创新人才推进计划” 中青年科技创新领军人才。 科技创新创业人才。 重点领域创新团队。 四、教育部人才计划 长江学者特聘教授：年龄不超过 45。 长江学者讲座教授：无年龄限制。 长江学者青年学者：年龄不超过 38。 创新团队发展计划：无年龄限制。 教学名师：无年龄限制。 参考 www.cailiaoniu.com/87889.html SCI、EI、核心期刊总览 学术期刊 国内期刊 普通期刊：省／国家级期刊 核心期刊：科技核心、北大中文核心、中科院核心（CSCD）、南大核心（CSSI）（社科类）等 国外期刊 SCI 自然科学索引 EI 工程索引 A&amp;HCI 艺术与人文科学索引 SSCI 社会科学索引 学术会议 EI 会议 CPCI SCI、EI 本质是数据库，他们从出版商那里抓取某些期刊的论文信息（题目／作者／摘要／参考文献），因此并不拥有文章内容版权。发 SCI、EI 并不是向这些 index 投稿，而是给 SCI 收录的期刊、EI 收录的会议／期刊投稿。因此，见刊并不代表检索（收录）。 SCI 自然科学索引全称 “Science Citation Index”。 SCI、SSCI、A&amp;HCI、CPCI 都收录在 Web of Science 数据库中。 SCIE 是 SCI 的扩展版（网络版）。 SCI 分区依据 汤森路透或中科院的期刊引证报告 JCR（Journal Citation Reports），国内毕业要求一般依据中科院的分区。分区查询软件：中科院文献情报中心期刊分区表（微信小程序），LetPub网站。 SCI 优劣一般以影响因子为衡量标准，但不绝对。 EI 工程索引全称“Engineering Index”。 EI 收录分为：会议论文集（CA）和期刊（JA）。 被 EI 收录的期刊（也称 EI 源刊）基本都属于一级刊物，含金量和认可度都比较高。 EI 会议好坏跨度较大，不一定全部都检索（收录），但相比 CPCI 成功率更大。 A&amp;HCI 和 SSCI人文社科类，不过多叙述。 CPCI 会议CPCI 在 WOS 旗下属于比较低端的数据库。 CPCI会议收录不难，但是无法承诺检索的。 参考 https://zhuanlan.zhihu.com/p/263012549 https://zhuanlan.zhihu.com/p/81293676 协会及出版商IEEE/ASME/ACM常见的协会有 IEEE（电气和电子工程师协会），ASME（美国机械工程师协会）和 ACM（国际计算机学会），是非营利性的科学组织，用于制定行业标准，出版杂志期刊，开展学术交流等。 IEEE／ASME 本身是学术组织，但旗下有许多期刊杂志和会议文集，通常每个专业分会都有自己的刊物。 IEEE 的文章大体分三类： IEEE Letter： 一般发表最新的研究成果，文章要求短小，理论推导要求不高； IEEE Magazine：一般要求用文字和图表来表述最新研究成果，不允许有过多的公式推导； IEEE Journal／Transaction：期刊杂志，需要有很大的创新点和详细的公式推导。 出版商常见的出版商有 Springer、Elsevier、Wiley、Taylor&amp;Francis Group。当然，IEEE、ACM等一些协会也会出版自己的杂志。 这些出版商旗下有许多期刊，同时也会有一些会议论文的项目，例如 Elsevier 的 Procedia、IEEE 的 Conference Program、Springer 的 Lecture Notes 系列。 EI收录－检索－出版商－会议组织者关系常说的 EI 检索的会议具体是什么？出版商与会议组织者的关系是什么？一般来说，流程是这样的： 会议组织者（例如学会／学校）举办一个会议，并打算将论文集出版，他们会联系出版商，例如 IEEE/ Springer/ Elsevier，报出自己要接受的文章篇数和会议主题； 出版商给他们一个报价，每篇文章多少钱；两者敲定，签订合同； 论文作者发现这个会议，写作，投稿并被接受，交注册费，提交最终稿； 会议组织者和出版商把最终稿整理成论文集，这样，会议组织者和出版商的交易结束； 而后，会议组织者把论文集扔给作者/开会，出版商（IEEE/ Springer/ Elsevier）更新自己的数据库，把文章放在IEEExplorer /Lecture Notes/ ScienceDirect 里面，这时候大家就能从出版商的数据库里面找到这些新发出的文章； 其他数据库（比如 EI）抓取出版商数据库里面的文章，比如 EngineeringVillage (EI) 在 IEEExplorer 抓取文章的内容；这时候作者的文章就能在EI里面查到了； 在会议召开的时候，文章可能在出版商的数据库里面都查不到，过一段时间能查到了，再过一段时间被其他数据库（比如 EI）抓取了，这时这时候就是所谓的“文章被 EI 检索（收录）”。 参考 https://blog.csdn.net/wodexihulu/article/details/7330843 https://zhuanlan.zhihu.com/p/149509820 https://blog.csdn.net/Neil_Pan/article/details/51848701]]></content>
      <categories>
        <category>科研基本知识</category>
      </categories>
      <tags>
        <tag>国家人才计划／项目</tag>
        <tag>SCI、EI、核心期刊</tag>
        <tag>会议文集出版流程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac 和 Win 在局域网下互传文件]]></title>
    <url>%2F2021%2F07%2F22%2FMac%E5%92%8CWin%E4%BA%92%E4%BC%A0%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[在局域网中，任意系统的两台电脑可以互传文件。 本文记录了如何设置 Win 和 Mac 来实现文件互传。 Step 1确认两台电脑连接到了同一网络（链接上即可，不一定可以上网）。 Step 2在 Windows 的设置中搜索 “管理高级共享设置”，点击 “启用文件和打印机共享”。新建一个文件夹，右键选择 “共享” 属性，将该文件夹设为共享文件夹。 Step 3在 Mac 上，右键 Finder，选择 “连接服务器”，在对话框中输入 ［smb://Windows 电脑 IP/共享文件夹名称］。点击连接之后输入 Windows 电脑的用户名密码。需要注意的是，如果 Windows 电脑使用微软账户进行登录的话，则用户名密码即为微软账户的用户名密码。 注：可以在命令行输入 “ipconfig” 来获得本机 IP 地址。 之后就可以拖动文件至共享文件夹实现共享了。]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>局域网技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 虚拟机安装及问题]]></title>
    <url>%2F2021%2F01%2F24%2FLinux%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85%E5%8F%8A%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[虚拟机可以方便的做实验——修改、测试，不必害怕出问题，可以随便折腾！出问题了大不了换一个虚拟机，原来的系统将没有任何影响。 本文记录了如何在 Windows 系统中安装 Linux 虚拟机的过程及相关问题。 安装虚拟机和 Ubuntu 系统虚拟机的安装过程主要参考这篇文章。其大致流程为： 安装 VMware 软件； 在 VMware 上安装 Linux 系统； 需要注意的是： VMware 软件可以不安装在 C 盘; Linux 的硬盘空间分配后不可改动，而内存空间和处理器内核总数可以再改动； 安装过程中若出现提示：“此主机支持 Intel VT-x，但 Intel VT-x处于禁用状态”，可以参考这篇文章，在 BIOS 中开启 Virtualization. 配置虚拟机网络成功安装 Vmware 虚拟机后，Win 的网络设置中可以找到两块网卡。 物理网卡 VMnet1 和虚拟网卡 VMnet8。 物理网卡，连接WLAN。 虚拟网卡VMnet8，连接内部LAN。一般虚拟机上网有两种方式：桥接模式和 NAT 模式。桥接模式配置更为简单，不过当电脑更换网络（链接不同 WIFI）之后，就需要更改虚拟机的配置，因此这种方式适合网络比较少更换的台式机；NAT 方式更适合笔记本电脑，这是因为使用的虚拟网卡并静态配置 ip 地址不会改变。 桥接模式和 NAT 模式的配置方法可以参考这个文章。 设置中文系统及安装拼音输入法该部分分为以下几步： 安装中文支持包：点击 settings -&gt; language support，然后点击 Install/Remove Languages，选择 chinese(simplified) -&gt; apply 安装 ibus 输入法：在 Terminal 中输入 1sudo apt-get install ibus ibus-clutter ibus-gtk ibus-gtk3 ibus-qt4 切换到 ibus 框架并安装拼音引擎： 12im-config -s ibussudo apt-get install ibus-pinyin 输入如下命令打开 ibus 设置，并在 input method 中添加刚刚安装的拼音输入法 1sudo ibus-setup 最后在系统设置的 Language 中将 Chinese(Pinyin) 添加到 input sources 即可。 该部分参考这篇文章和这篇文章。 Linux 中的一些命令及问题什么是 SSH该部分参考这篇文章。 简单说，SSH 是一种网络协议，用于计算机之间的加密登录。如果一个用户从本地计算机，使用SSH 协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。最早的时候，互联网通信都是明文通信，一旦被截获，内容就暴露无疑。1995年，芬兰学者 Tatu Ylonen 设计了 SSH 协议，将登录信息全部加密，成为互联网安全的一个基本解决方案，迅速在全世界获得推广，目前已经成为 Linux 系统的标准配置。 SSH之所以能够保证安全，原因在于它采用了公钥加密。整个过程是这样的： 远程主机收到用户的登录请求，把自己的公钥发给用户。 用户使用这个公钥，将登录密码加密后，发送回来。 远程主机用自己的私钥，解密登录密码，如果密码正确，就同意用户登录。 这个过程本身是安全的，但是实施的时候存在一个风险：如果有人截获了登录请求，然后冒充远程主机，将伪造的公钥发给用户，那么用户很难辨别真伪。因为不像 https 协议，SSH 协议的公钥是没有证书中心（CA）公证的，也就是说，都是自己签发的。可以设想，如果攻击者插在用户与远程主机之间（比如在公共的 wif i区域），用伪造的公钥，获取用户的登录密码。再用这个密码登录远程主机，那么 SSH 的安全机制就荡然无存了。这种风险就是著名的“中间人攻击”（Man-in-the-middle attack）。 apt 是什么Advanced Packaging Tool（apt）是 Linux 下的一款安装包管理工具。APT 是一个客户/服务器系统。在服务器上先复制所有 DEB 包（DEB 是 Debian 软件包格式的文件扩展名），然后用 APT 的分析工具（genbasedir）根据每个 DEB 包的包头（Header）信息对所有的 DEB 包进行分析，并将该分析结果记录在一个文件中，这个文件称为 DEB 索引清单，APT 服务器的 DEB 索引清单置于 base 文件夹内。一旦 APT 服务器内的 DEB 有所变动，一定要使用 genbasedir 产生新的 DEB 索引清单。客户端在进行安装或升级时先要查询 DEB 索引清单，从而可以获知所有具有依赖关系的软件包，并一同下载到客户端以便安装。当客户端需要安装、升级或删除某个软件包时，客户端计算机取得 DEB 索引清单压缩文件后，会将其解压置放于 /var/state/apt/lists/，而客户端使用 apt-get install 或 apt-get upgrade 命令的时候，就会将这个文件夹内的数据和客户端计算机内的 DEB 数据库比对，知道哪些 DEB 已安装、未安装或是可以升级的。 apt-get update 和 apt-upgrade 有什么区别在windows下安装软件，我们只需要双击 .exe 文件即可。但在 Linux 下，不是这样的。每个 Linux 的发行版，比如 Ubuntu，都会维护一个自己的软件仓库，我们常用的几乎所有软件都在这里面。这里面的软件绝对安全，而且绝对的能正常安装。 如何安装这些软件呢？在 Ubuntu 下，我们维护一个源列表，源列表里面都是一些网址信息，这每一条网址就是一个源，这个地址指向的数据标识着这台源服务器上有哪些软件可以安装使用。可以通过如下命令查看1sudo gedit /etc/apt/sources.list 当在这个文件里加入或者注释（加#）掉一些源并保存后。我们的源列表里指向的软件就会增加或减少。之后要做的就是：1sudo apt-get update 这个命令，会访问源列表里的每个网址，并读取软件列表，然后保存在本地电脑。我们在软件包管理器里看到的软件列表，都是通过update命令更新的。update后，可能需要upgrade一下。1sudo apt-get upgrade 这个命令，会把本地已安装的软件，与刚下载的软件列表里对应软件进行对比，如果发现已安装的软件版本太低，就会提示你更新。如果你的软件都是最新版本，会提示你升级了几个软件包，新安装了几个软件包，要卸载几个软件包，有几个软件包未被升级。 总而言之，update是更新软件列表，upgrade是更新软件。该部分参考这篇文章。 解决 E: Could not get lock /var/lib/apt/lists/lock1sudo apt-get update 的时候遇到了如下问题12E: Could not get lock /var/lib/apt/lists/lock - open (11: Resource temporarily unavailable)E: Unable to lock directory /var/lib/apt/lists/ 表明当前有某个进程正在apt-get，然而我并没有使用任何命令，于是需要 kill 掉进程。参考这个文章，解决方法是：1sudo rm /var/lib/apt/lists/lock VMware 虚拟机遇到的问题Linux 虚拟机开机黑屏前后尝试了 3 种方法，不知道哪个最终起效了，参考了这个文章 方法一 用管理员身份打开 cmd， 输入 netsh winsock reset，重启计算机。(未解决，仍黑屏) 方法三 打开 VMware 的首选项，选择设备，取消 “启用虚拟打印机” 勾选，重启。(未解决，仍黑屏) 方法三 在虚拟机的设置中，取消显示器的 3D 图像勾选，重启。(成功) 网友提示：虚拟机在用完后最好挂起，不要关机！！！ VMware Workstation 报错当虚拟机死机时，我们可以通过 Win 任务管理器杀死进程。再次打开虚拟机时经常遇到如下 问题： 123VMware Workstation 无法连接到虚拟机，请确保您有权运行该程序，访问该程序使用的所有目录以及访问所有历史文件目录。未能将管道连接到虚拟机：所有管道范例都在使用中。 解决方法： 打开 Win 系统中的“服务”，找到 VMware Workstation Server，右键属性，将启动类型换成 (自动延时启动)，然后确认退出，重启电脑，再次以管理员身份打开电脑即可。 Win 与虚拟机无法拖拽文件右键 VMware 中虚拟机选项卡，选择“安装 VMware Tools”。打开 Linux 文件夹，可以看到一个 VMware Tools 的驱动盘，将里面的压缩文件拷贝出来。解压该文件可以看到一个名叫 “vmware-tools-distrib” 的文件。在 Terminal 中 cd 至该文件夹，输入 1sudo ./vmware-install.pl 一路回车即可完成安装。上述安装过程参考了这个 和 这个。 重启虚拟机之后，就可以在 Win 和虚拟机之间复制粘贴了，不过传输速度极慢，遂采用共享文件夹的方法。 首先在 Win 中新建一个 myshare 文件夹；之后打开 VMware 中虚拟机选项卡，选择设置；然后在“选项 — 共享文件夹” 中选择“启总是用”，并添加 myshare 文件夹路径即可。 传输文件文件时，将 Win 中文件拖至 myshare 中，然后打开虚拟机中的 /mnt/hgfs/myshare 文件夹，即可看到共享的文件。打开 /mnt/hgfs/myshare 文件夹的方法： 1nautilus /mnt/hgfs/myshare 上述过程参考了这个博客。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCG第四次作业]]></title>
    <url>%2F2021%2F01%2F14%2FCCGhw-4%2F</url>
    <content type="text"><![CDATA[2020年暑假，顾险峰教授于线上讲授计算共形几何系列课程，本文记录了第四次作业的实现过程。本文框架： 代码环境配置； 代码补全思路。 代码环境配置代码环境配置与第一次相同 下载，解压，CMake代码； 补全 SphericalHarmonicMap.cpp 文件，并在 Xcode 中 build项目； 打开 Terminal，cd 至 /build/spherical_harmonic_map，输入 ./Debug/SphericalHarmonicMap ../../data/brain.m (或 bimba.m) 可看到如下结果 0亏格曲面 press ‘h’ 可以得到 0亏格曲面到球面上的调和映射 代码补全思路第四次作业要求补全 SphericalHarmonicMap.cpp 文件。 数据结构与第一次作业相同，SphericalHarmonicMap.h 定义了适用于 SphericalHarmonicMap.cpp 的点、边、半边、面的类。 代码补全思路0亏格曲面到球面上的调和映射 $\varphi$ 具有如下表达式 \Delta_g \varphi(x) = 0, \quad \varphi(x)\in\mathbb{S}^2.本次作业是通过模拟热流的方法得到该调和映射的，即考虑 \frac{\partial\varphi}{\partial t} = - \Delta_g \varphi, \quad \varphi(x)\in\mathbb{S}^2.算法大致流程如下： 利用 Gauss 映射给出 $\varphi$ 的初值； 计算等式右端的 Laplacian （表达式由第二次作业给出）； 由于像空间为球面，因此将 Laplacian 向 $\mathbb{S}^2$ 上投影得到切向量 $D\varphi$； 更新下一时刻的 $\varphi$，并归一化； 为保证计算的唯一性，需要商掉一个莫比乌斯变换，即，将映射的像平移至质心的位置，并归一化。 重复 2-5 过程直至调和能量 E(\varphi) = \sum_{(i,j)\in Edge}w_{ij}(\varphi(v_j)-\varphi(v_i))^2收敛到阀值即可。 需要注意的是，在计算过程中，调和能量应当递减。如果没有递减，应当减小计算步长。我采用的步长如下： brain.m: step_length = 2e-1, epsilon = 1e-5;bimba.m: step_length = 2e-2, epsilon = 5e-3. 调和能量最终分别收敛为：26.2937 和 29.0689。]]></content>
      <categories>
        <category>Computational Conformal Geometry</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[单复变函数基础知识]]></title>
    <url>%2F2021%2F01%2F06%2F%E5%8D%95%E5%A4%8D%E5%8F%98%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[本文总结了单复变函数中的一些基础知识，作为 CCG 第三次作业的补充。包含以下知识点：全纯函数／形式；Riemann 面；共形映射；黎曼映照；单值化定理；调和微分形式；Hodge 定理／Hodge 分解；全纯微分；等温坐标。 定义(全纯函数) 假设复值函数 $f: \mathbb{C} \rightarrow \mathbb{C}$ 将 $ z = x + iy $ 映射到 $w = u + iv$，如果函数满足柯西-黎曼方程： \frac{\partial u}{\partial x} = \frac{\partial v}{\partial y}, \quad \frac{\partial u}{\partial y} = - \frac{\partial v}{\partial x}则称函数是全纯的（也称复解析的）。如果其逆函数也是全纯的，则称为双全纯的。 值得注意的是，如果记算子 \frac{\partial}{\partial z} = \frac{ 1}{ 2}(\frac{\partial}{\partial x}-i \frac{\partial}{\partial y}), \quad \frac{\partial}{\partial \bar{z}} = \frac{ 1}{ 2}(\frac{\partial}{\partial x}+i \frac{\partial}{\partial y})则柯西-黎曼方程有更加简介的复表示 \frac{\partial w}{\partial \bar{z}} = 0.如果映射 $f(z) = w$ 是全纯的，那么 $ dw = \frac{\partial w}{\partial \bar{z}}dz$，则由该映射诱导的拉回度量为 dw d\bar{w} = |\frac{\partial w}{\partial \bar{z}}|^2dz d\bar{z}拉回度量和源度量相差一个非负标量函数，因此全纯映射是共形映射。 定义（Riemann面） 假设 $M$ 是一个二维的拓扑流形，配有图册 $\mathcal{A} = \{(U_{\alpha},\varphi_{\alpha})\}$，每个局部坐标为复数坐标 $\varphi_{\alpha}: U_{\alpha} \rightarrow \mathbb{C}$，并且坐标变换为双全纯函数 \varphi_{\alpha\beta}:\varphi_{\alpha}(U_{\alpha}\cap U_{\beta})\rightarrow\varphi_{\beta}(U_{\alpha}\cap U_{\beta})则图册被称作是一个共形图册，共形图册可以定义一个等价关系，称为共形结构。一个带有共形结构的拓扑曲面被称为是Riemann 面。 共形结构可以用来测量角度，但无法测量面积、长度。因此，弱于黎曼度量。 定义（共形映射） 若映射 $f:(M,\{(U_{\alpha},\varphi_{\alpha})\})\rightarrow (N,\{(V_{\beta},\psi_{\beta})\})$ 的局部表示是双全纯的，则称它是黎曼面之间的共形映射。黎曼几何中定义：流形 $(M,g)$ 和 $(N,\tilde{g})$ 之间的映射 $f$ 称为是共形映射，如果存在 $M$ 上正的光滑函数 $\phi$ 满足 f^{*}\tilde{g} = \phi g.定理（黎曼映照） 给定复平面上单连通区域 $\Omega\subset \mathbb{C}$ 和一点 $z_0\in\Omega$，则存在唯一的解析函数 $f:\Omega \rightarrow \mathbb{D}$ 满足 $f(z_0) = 0$ 和 $f^{\prime}(z_0)&gt;0$，使得 $f$ 定义了一个从 $\Omega$ 到圆盘 $\mathbb{D}$ 的双射。 黎曼映照的计算方法可以通过环带的典范共形映射得到。 定理（单值化定理） 任意一个连通的 Riemann 面都和三个标准 Riemann 面中的一个共形等价：单位球面 $\mathbb{S}^2$，复平面 $\mathbb{C}$，单位圆盘$\mathbb{D}$。 下面介绍调和微分形式 定义（调和微分形式） $M$ 上的 $k$-微分形式 $\omega\in\Omega^k(M)$ 被称为调和微分形式，如果 d\omega = 0, \quad \delta \omega = 0.这等价于 \Delta \omega = 0,其中，$\Delta = d\delta+\delta d$. Hodge 定理告诉我们调和 $k$-形式群和 $k$ 阶 de Rham 上同调群一一对应。 定理（Hodge 定理） 封闭光滑黎曼流形的每一个 de Rham 上同调类都有且仅有一个调和微分形式与之对应。 Hodge 分解定理告诉我们，$k$-形式可以分解为恰当形式、余恰当形式和调和形式。 定理（Hodge 分解） 对于 $M$ 上的 $k$-微分形式 $\xi\in\Omega^k(M)$，存在唯一的 $\tau\in\Omega^{k-1}(M)$，$\eta\in\Omega^{k+1}(M)$ 和 调和 $k$-形式 $\omega$ 满足 \xi = d \tau + \delta \eta + \omega. Hodge 定理和 Hodge 分解定理为计算调和 1-形式群的基底指明了方向，相见 CCG 第三次作业。 为了介绍全纯 1-形式，首先定义亚纯函数和亚纯微分。 定义（亚纯函数） 一个复平面的开子集 $\Omega\subset\mathbb{C}$ 上的亚纯函数是一个在 $\Omega$ 上除一个或若干个孤立点集合之外的区域都全纯的函数，那些孤立点称为该函数的极点。 定义（亚纯微分／全纯微分） 假设 $\omega$ 是 Riemann 面上的复微分形式，具有局部表示 \omega = f_{\alpha}(z_{\alpha})dz_{\alpha}^md\bar{z}_{\alpha}^n,其中，$f_{\alpha}(z_{\alpha})$ 是亚纯函数，$m,n\in\mathbb{Z}$，则 $\omega$ 称为 $(m,n)$ 型的亚纯微分；如果 $f_{\alpha}(z_{\alpha})$ 是全纯函数，则 $\omega$ 称为全纯微分。(1,0) 型的全纯微分称为全纯 1-形式。 全纯 1-形式可以由调和 1-形式计算出来。它可以用来生成 Riemann 面上的等温坐标，也可以用来计算 Riemann 映照，详见 CCG 第三次作业。 一般来说，流形无法用一个坐标系整体覆盖，只能被一族局部坐标系覆盖。局部坐标系的选取具有很大自由度，在曲面上，最为常用的一种特殊局部坐标系，叫做等温坐标系。 定义（等温坐标） 假设曲面 $(S,g)$ 上的开集 $U$ 有局部坐标 $(x,y)$，使得度量张量具有形式 g(x,y) = e^{2\lambda(x,y)}(dx^2+dy^2)则称 $(x,y)$ 为等温坐标系。这意味着曲面的黎曼度量和平面欧式度量共形等价。 光滑曲面总存在等温坐标。 定理（等温坐标存在性） $(S,g)$ 是光滑曲面。对于任意一点 $p \in S$，存在开集 $U(p)\subset S$，使得此开集内存在等温坐标系 $(x,y)$。 这个定理可以帮助我们很好的判断一个曲面是否是黎曼面。 推论 可定向的度量曲面都是 Riemann 面。 参考文献[1] http://blog.sciencenet.cn/home.php?mod=space&amp;uid=2472277]]></content>
      <categories>
        <category>Computational Conformal Geometry</category>
      </categories>
      <tags>
        <tag>复变函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCG第三次作业]]></title>
    <url>%2F2021%2F01%2F04%2FCCGhw-3%2F</url>
    <content type="text"><![CDATA[2020年暑假，顾险峰教授于线上讲授计算共形几何系列课程，本文记录了第三次作业的实现过程。本文框架： 代码环境配置； 代码补全思路。 代码环境配置代码环境配置与第一次相同 下载，解压，CMake代码； 补全 HodgeDecomposition.cpp 文件，并在 Xcode 中 build项目； 打开 Terminal，cd 至 /build/hodge_decomposition，输入 ./Debug/HodgeDecomposition ../../data/eight/eight.m ../../data/eight/eight.open.m ../../textures/coordinate_256.bmp. 即可看到如下结果 曲面上的拉回正交网 图中显示出拉回的等温坐标有退化情形，即没有全局定义的等温坐标，由 Poincare-Hopf 定理可知这是由拓扑带来的限制。我们可以通过全纯 1-形式群的基底分别拉回正交网，使这一族正交网拼起来覆盖整个曲面。 press ‘n’ 可以得到其他全纯 1-形式基底的拉回的等温坐标 全纯 1-形式基底 代码补全思路第三次作业要求补全 HodgeDecomposition.cpp 文件。 数据结构与第一次作业相同，HodgeDecomposition.h 定义了适用于 HodgeDecomposition.cpp 的点、边、半边、面的类。 代码补全思路本次作业是通过 Hodge 分解理论来得到曲面上的调和 1-形式，进而得到曲面上的全纯 1-形式。其大致流程如下： 调和 1-形式的计算. 首先计算下同调群 $H_1(\mathcal{T},\mathbb{R})$ 的基底 $\{\gamma_1, \dots, \gamma_{2g}\}$ i.e. $\pi_1({\mathcal{T}})$ 的基底；然后计算上同调群 $H^1(\mathcal{T},\mathbb{R})$ 的基底 $\{\eta_1, \dots, \eta_{2g}\}$ i.e. $\eta_k$ 的特征形式 (参见书 5.7 节)；每一个 $\eta_k$是闭的但不一定是调和的，考虑 $\eta_k +d f_k$，通过求解 $\delta(\eta_k +d f_k) = 0$ 即可得到调和 1-形式群的基底 $\tau_k := \eta_k +d f_k,(k = 1,\dots,2g).$ 该部分对应代码中的 random_harmonic_form() 函数。 全纯 1-形式的计算. 调和 1-形式群的基底为 $\{\tau_1, \dots, \tau_{2g}\}$，每个调和 1-形式的共轭 1-形式仍是调和的，并且它们共同构成全纯 1-形式群的基底 \{\tau_1 + \sqrt{-1}*\tau_1, \dots, \tau_{2g} + \sqrt{-1}*\tau_{2g}\}.要计算 $ *\tau_{j}$ 可以假设 *\tau_{j} = \sum_{k=1}^{2g}\lambda_{jk} \tau_{k} .Slides 中给出了 $ \tau_{i} \wedge \tau_{k} $ 和 $ \tau_{i} \wedge *\tau_{j} $ 的计算方法。 于是，由下面的线性方程组即可求得 $*\tau_{j}$ \int_{\mathcal{T}}\tau_i \wedge *\tau_j = \sum_{k = 1}^{2g}\lambda_{jk}\int_{\mathcal{T}} \tau_i \wedge \tau_k, \quad 1\leq i,j \leq 2g.这样，就得到了曲面上的全纯 1-形式群的基底。该部分对应代码中的 calc_holo_1_form() 函数。 这两部分根据 slides 中的公式可以很容易的补全代码，注意正负号即可。 全纯 1-形式的应用. 对于一个全纯 1-形式 $\omega$，给定点 $p\in U$，定义函数 $f:U\rightarrow \mathbb{C}$ f(q) = \int_p^q \omega,可知 $f$ 是良定的，即不依赖于路径。由于 $\omega$ 是全纯 1-形式，故其变上限积分 $f$ 是全纯的，从而可以将复平面上的直角坐标系共形地拉回到曲面上（见下图），该部分对应代码中的 integration() 函数。全纯 1-形式还可以用来计算拓扑环带的典范共形映射，代码中没有涉及，但 slides 和书中有详细构造方法，可自行编写。 等温坐标和平面上的直角坐标 值得一提的是，代码的 data 中给了两个网格：eight.m 和 eight.open.m，如下图所示 eight.m (黑色) 和 eight.open.m (粉色) 作者将这两个网格关联起来（father 结构），并将源网格 (eight.m) 上计算出的全纯 1-形式和定义 $f$ 的过程放到新网格 (eight.open.m) 上，这样做的目的是为了避免下面的情况出现 （左图）拉回网格会在 cut graph 上出现问题；（右图）带有相邻关系的 f 的像. 只有源网格时，由于调和 1-形式是由 cut graph 的特征形式给出的，因此，调和 1-形式在其对应的环路上会突变为零，导致 $f$ 突变 (见下图)，由源网格得到的新网格很好的避免了这个问题。 (左图) 只有一个网格时，f值域放大，存在大突变；(右图) 两个网格时，f值域放大，不存在大突变. 两个网格的 father 关系由作者不加说明的直接给出。通过分析两个网格数据，我发现新图比源图的顶点数少，并且存在 4 个点联系同一个 father 的情况，因此猜测：去掉源图的 cut graph 和与之相连的边，合并公共边在 cut graph 上的 diamond 的两个顶点（分配同一个 father），从而得到新的网格。 本次作业不论从理论上还是代码实现上，都充满了巧思，值得回味！]]></content>
      <categories>
        <category>Computational Conformal Geometry</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[安装及使用detri2软件]]></title>
    <url>%2F2020%2F12%2F22%2F%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8detri2%E8%BD%AF%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[本文将简略介绍 2D 网格生成软件 detri2 的安装及使用方法，以免踩坑。本文框架为： 下载及安装 detri2； detri2 基本操作。 detri2可以在平面区域生成 delaunay triangulation，是 SI Hang 博士开发的一款软件。 Windows下安装首先下载 QT v5.9.9，选择安装组件 MinGW32，其他组件可以参考详细过程。打开 detri2.pro，进行构建配置和运行设置，并将 MinGW32 的安装目录加入到系统环境变量中（此电脑—属性—环境变量—系统变量（Path）— 新建 C:\Qt\Qt5.9.9\Tools\mingw530_32\bin）。 在 Windows 上直接构建和运行会报 “gmpxx.h not found” 这是因为没有在 MinGW 中安装 GMP库。 GMP 是一个开源的数学运算库，它可以用于任意精度的数学运算，包括有符号整数、有理数和浮点数，是进行大数运算比较好的选择。GMP 库只提供了一个 makefile 的文件，这意味着需要 gcc 环境支持。前面安装的 MinGW32 可以提供 gcc 环境，但是单独的 MinGW 不能编译 makefile 文件，要编译 makefile 文件，还需要安装 msys 工具，它可以在 Windows 下搭建一个类 linux 环境。详细安装过程可以参考这个 或者中文翻译（没贴全），需要注意的是应下载 MSYS 1.0.11及以上版本（MSYS 1.0.10是大坑）。 安装完 GMP 库后，在 .project 中添加外部库，注意按下图所示添加，否则会报 “no rule to make target”。 安装完 GMP 后程序报错 “mpfr.h not found”，在 win 下尝试了几次添加 mpfr 库失败后，转用 Mac 系统安装 detri2。 Mac下安装下载并安装 QT（我用的是 v5.9.0），安装时选择 macOS。在官网下载 GMP 和 MPFR，将解压后的 gmp-6.2.1 和 mpfr-4.1.0 拷贝至 /usr/local。 首先安装 GMP 库。打开Terminal，cd 至 gmp-6.2.1，输入1234./configure --enable-cxxmakemake checkmake install 运行成功后，GMP 库就被安装在了 /usr/local/lib 和 /usr/local/include 中。 接着，安装 MPFR 库。cd 至 mpfr-4.1.0，输入 1234./configure --disable-shared --enable-static --with-gmp=../gmp-6.2.1makemake checkmake install 运行成果后，MPFR 库就被安装在了 /usr/local/lib 和 /usr/local/include 中。 用 QT 打开 detri2qt.pro，这时项目就可以成功构建了。但在运行项目时，出现了如下问题 1dyld: Symbol not found: __cg_jpeg_resync_to_restart 通过查询得知，这是 OS X 上常见的 dyld issue，解决方法参考了这个： 在 QT 中点击 项目—&gt;运行—&gt;Run Environment (详情)。在 DYLD_LIBRARY_PATH 和 DYLD_FRAMEWORK_PATH 变量值前添加如下语句 1/System/Library/Frameworks/ImageIO.framework/Resources: 之后运行项目即可得到下图的界面 可在 build 后的文件中拷贝 detri2qt （应用程序）至桌面方便使用。 detri2 基本操作detri2 可以通过手动的方式加点，也可以随机生成一组点。点击 Generate Mesh（command+M）得到下图视窗 其中， Incremental construction：根据点集自动生成 delaunay 网格（一般选择 option：weighted &amp; with constraints）； Lawson flipping：用来展示如何通过 Lawson flip 来得到 delaunay 网格（一般不用此选项）； Mesh refinement/coarsening：自动添加／删除点集，以适应 option 中关于最小角度（一般不超过 30 度）和最大边长（太小软件可能会崩溃）的限制； Mesh smoothing：自动移动点的位置来优化网格中各三角的角度。 例子首先，点击解界面中的矩形生成一个四个点四个边的矩形 然后，点击生成网格，并按下图设置生成网格信息 点击 Generate 即可得到如下 delaunay 网格 最后，通过 Mesh smoothing 可以优化网格质量，如下所示 通过点击界面中的 Edge lengths 选项，可以查看边长是否符合约束，如下所示 以上就是 detri2 的简单使用过程。值得注意的是，频繁操作和不合理的边长或角度限制会导致程序崩溃。]]></content>
      <categories>
        <category>Mesh Generate</category>
      </categories>
      <tags>
        <tag>detri2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac系统基本知识]]></title>
    <url>%2F2020%2F12%2F09%2FMac%E7%B3%BB%E7%BB%9F%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[在此整理了Mac根目录结构以及相关的 Linux 系统知识。 Mac根目录下都有什么打开Macintosh HD你会发现内中有四个文件夹分别有——应用程序(Applications)、系统(System)、用户(User)、资料库(Library)。四个文件夹中又分别各有若干数量的文件夹存在。 1.Applications：这个是存放各种软件的位置。 2.System: 包含由Apple安装的系统软件。这此资源是系统正常运行所必须的，位于启动卷宗中。 3. Library：系统资源库。 比如字体、ColorSync 配置、偏好设置以及插件都应该安装在 Library 目录下适当的子目录中。 Application Support包含了应用相关的数据以及支持文件，比如第三方的插件，帮助应用，模板以及应用使用到但是并不需要用来支持运行的额外资源文件。按照惯例，所有这些内容都会被存储在以应用名称命名的子目录当中。 Assistants包含了帮助用户进行配置或者其它任务的程序。 ColorPickers包含了用来选择色彩的资源，它们根据某种模型，比如 HLS (色彩角、饱和度、亮度) 选择器或者 RGB 选择器。 ColorSync包含了 ColorSync 配置和脚本。 Components包含了系统包和扩展。 Contextual Menu Items包含了用于扩展系统级菜单的插件。 Dictionaries包含了系统自带的字典文件。 Desktop Pictures桌面图片目录。 Documentation包含了供计算机用户和管理员参考的文档文件和 Apple 帮助包。 Extensions包含了设备驱动和其它内核扩展。(只存在于系统域当中。) Favorites包含了指向经常访问的文件夹、文件或者网站的别名。(仅仅存在于用户域当中。) Fonts包含了用于显示和打印的字体文件。 Java包含了Java运行环境。 StartupItems包含了在系统导入时刻运行的系统以及第三方脚本和程序。 4. Users： 包含了某个用户专有的资源。 Applications包含仅仅当前用户可用的应用。 Desktop 包含了 Finder 在当前登录用户桌面上显示的桌面项。 Documents 包含了用户的个人文档。 Download 包含了下载的各种文档。 Library（隐藏）通过 command+shift+G: ~/Library 进入，其中包含了应用设置、偏好设置一起其他用户专有的系统资源（不同于上边的那个Library，这里是用户的数据不是系统的）。 在Mac OS X上, 根目录下还有几个隐藏文件，其中的六个是UNIX内核系OS都必会具备的档案夹, 分别是: bin————-储存有基本的UNIX指令 sbin————UNIX 系统指令的储存地方, 是比较进阶的指令 etc————-系统设定档桉储存地方 var————-改动频繁的档桉, 都置放于此, 例如各log档桉 tmp————系统的暂存档 usr————-UNIX的使用者专用档桉夹 常见缩写bin是单词binary的缩写 是二进制的意思 由于一些约定俗成的原因我们一般都将可执行文件放到 bin 目录中. Linux 中的某些重要的目录： 主目录：/root、/home/username 用户可执行文件：/bin、/usr/bin、/usr/local/bin 系统可执行文件：/sbin、/usr/sbin、/usr/local/sbin 其他挂载点：/media、/mnt 配置文件：/etc 临时文件：/tmp 所需要的装置文件：/dev 内核和Bootloader：/boot 服务器数据：/var、/srv 系统信息：/proc、/sys 共享库：/lib、/usr/lib、/usr/local/lib Linux的usr中都有什么/usr不是user的缩写，其实usr是Unix Software Resource的缩写， 也就是Unix操作系统软件资源所放置的目录，而不是用户的数据；所有系统默认的软件都会放置到/usr, 系统安装完时，这个目录会占用最多的硬盘容量 目录 应放置文件内容 /usr/X11R6/ 为X Window System重要数据所放置的目录，之所以取名为X11R6是因为最后的X版本为第11版，且该版的第6次释出之意。 /usr/bin/ 绝大部分的用户可使用指令都放在这里。请注意到他与/bin的不同之处。(是否与开机过程有关) /usr/include/ c/c++等程序语言的档头(header)与包含档(include)放置处，当我们以tarball方式 (*.tar.gz 的方式安装软件)安装某些数据时，会使用到里头的许多包含档。 /usr/lib/ 包含各应用软件的函式库、目标文件(object file)，以及不被一般使用者惯用的执行档或脚本(script)。 某些软件会提供一些特殊的指令来进行服务器的设定，这些指令也不会经常被系统管理员操作， 那就会被摆放到这个目录下啦。要注意的是，如果你使用的是X86_64的Linux系统， 那可能会有/usr/lib64/目录产生 /usr/local/ 统管理员在本机自行安装自己下载的软件(非distribution默认提供者)，建议安装到此目录， 这样会比较便于管理。举例来说，你的distribution提供的软件较旧，你想安装较新的软件但又不想移除旧版， 此时你可以将新版软件安装于/usr/local/目录下，可与原先的旧版软件有分别啦。 你可以自行到/usr/local去看看，该目录下也是具有bin, etc, include, lib…的次目录 /usr/sbin/ 非系统正常运作所需要的系统指令。最常见的就是某些网络服务器软件的服务指令(daemon) /usr/share/ 放置共享文件的地方，在这个目录下放置的数据几乎是不分硬件架构均可读取的数据， 因为几乎都是文本文件嘛。在此目录下常见的还有这些次目录：/usr/share/man：联机帮助文件 /usr/share/doc：软件杂项的文件说明 /usr/share/zoneinfo：与时区有关的时区文件 /usr/src/ 一般原始码建议放置到这里，src有source的意思。至于核心原始码则建议放置到/usr/src/linux/目录下。 什么是root用户root用户可以在Linux系统上做任何操作，权限没有收到任何限制。一般需要root权限的任务包括：移动文件或者文件夹in或者out of 系统目录，复制文件到系统目录，赋予或者收回用户权限，系统维护和安装一些应用程序，例如：安装RPM格式的软件通常需要root权限，因为需要写一些信息到系统目录。还有一个需要注意的就是，对于小于1024端口的知名端口，只有root用户才可以有权限侦听，如果应用程序需要侦听小于1024的端口，可以采用临时提权，侦听端口之后，再收回权限的方式进行。如果一直使用root运行应用程序，将会很危险，Linux的sendmail就曾经出现过使用root运行sendmail因为要侦听25端口，结果sendmail程序出问题之后，可以通过这个安全问题控制整台服务器，因为它是用root用户启的。 Linux sudo命令以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。普通用户使用sudo 来执行只有root才能执行权限的命令，跟用root用户执行是不一样的，因为这时候他用的还是普通用户的环境变量。 参考[1] https://www.cnblogs.com/ftl1012/p/9278578.html [2] https://blog.csdn.net/sdaujsj1/article/details/102716939 [3] http://mac.pcbeta.com/thread-67417-1-1.html [4] https://blog.csdn.net/jimmyleeee/article/details/7886779 [5] https://www.pathname.com/fhs/pub/fhs-2.3.html#PURPOSE18]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Linux 基础</tag>
        <tag>Mac 根目录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++大补丸3]]></title>
    <url>%2F2020%2F08%2F05%2FC%2B%2B%E5%A4%A7%E8%A1%A5%E4%B8%B83%2F</url>
    <content type="text"><![CDATA[编程小白在此整理一些C++基础知识。本文框架： Mac 下快速设置 VScode launch.json C 运算符号 Eigen 库稀疏矩阵 Mac 下快速设置 VScode launch.json在 Mac 下，Xcode 是许多人的首选 IDE，但对于一些轻量级的 C++ 练习来说 Xcode 有些不方便。此时，我们可以选择 VScode 编写 C++ 代码，但是 VScode 只是一个文本编辑器，我们需要调用 g++ 或者 clang 进行编译，这时就要对编译过程进行配置。 VSCode里有一个Native Debug插件能大大简化上述配置。 使用方法： 新建文件夹，将 .cpp 文件放入； Open folder，Run &amp; Debug； 选择 C++(GDB/LLDB)，选择 g++； 可以看到，自动生成了 .vscode 文件和 launch.json。 C 运算符号增量运算符（++）增量运算符以两种形式进行支持：后缀增量运算符 x++ 和前缀增量运算符 ++x 1234int a = 3;cout&lt;&lt; a &lt;&lt; endl; //output 3cout&lt;&lt; a++ &lt;&lt; endl; //output 3cout&lt;&lt; a &lt;&lt; endl; //output 4 1234int b = 3;cout&lt;&lt; b &lt;&lt; endl; //output 3cout&lt;&lt; ++b &lt;&lt; endl; //output 4cout&lt;&lt; b &lt;&lt; endl; //output 4 复合赋值1234x op= y // 等效于x = x op y// op 可以为 + - * / % 计算优先级优先级由高到低的顺序： 后缀增量 x++ 和减量 x-- 运算符 前缀增量 ++x 和减量 --x 以及一元 + 和 - 运算符 乘法 *、/ 和 % 运算符 加法 + 和 - 运算符 Eigen库稀疏矩阵Eigen自带的稀疏矩阵分解功能包括LDLt、LLt分解（即Cholesky分解）、LU分解、QR分解、共轭梯度解矩阵等。 基本稀疏矩阵操作Eigen中使用 Eigen::Triplet&lt;Scalar&gt;来记录一个非零元素的行、列、值，填充一个稀疏矩阵，只需要将所有表示非零元素的Triplet放在一个 std::vector中即可传入即可。除了求逆等功能外，Eigen::SparseMatrix有和Eigen::Matrix几乎一样的各种成员操作函数，并且可以方便混用。 创建一个稀疏矩阵 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include "eigen3/Eigen/Sparse"// 创建矩阵： // 0 6.1 0 0 // 0 0 7.2 0 // 0 0 8.3 0 // 0 0 0 0int main ( ) &#123; using namespace Eigen ; SparseMatrix &lt; double &gt; A ( 4 , 4 ) ; std::vector &lt; Eigen::Triplet&lt;double&gt; &gt; triplets ; int r [ 3 ] = &#123; 0 , 1 , 2 &#125; ; // 非零元素的行号 int c [ 3 ] = &#123; 1 , 2 , 2 &#125; ; // 非零元素的列号 double val [ 3 ] = &#123; 6.1 , 7.2 , 8.3 &#125; ; // 非零元素的值 for ( int i = 0 ; i &lt; 3 ; ++ i ) triplets.push_back(Eigen::Triplet&lt;double&gt;(r[i], c[i], val[i])); // 填充Triplet A. setFromTriplets ( triplets.begin ( ) , triplets.end ( ) ) ; // 初始化系数矩阵 std :: cout &lt;&lt; "A = " &lt;&lt; A &lt;&lt; std :: endl ; // output稀疏表示 std :: cout &lt;&lt; "A * A = \n" &lt;&lt; A * A &lt;&lt; std :: endl ; // output普通表示 MatrixXd B = A ; // 可以和普通稠密矩阵方便转换 std :: cout &lt;&lt; "B = \n" &lt;&lt; B &lt;&lt; std :: endl ; std :: cout &lt;&lt; "A * B = \n" &lt;&lt; A * B &lt;&lt; std :: endl ; // 二者可以直接运算 return 0 ;&#125; 附：在VScode中导入Eigen库 下载Eigen库，解压至项目文件夹，重命名为eigen3； command + shift + p，选择 C/C++:Edit Configurations(JSON)； 在 “includePath” 中 添加路径 “/ProjectFolder/eigen3/“，重启VScode； 注意事项 如果使用std::vector中的emplace_back向稀疏矩阵中添加元素，可能会因为C++11的问题报错 “No member named emplace_back “，可以参考： C++ compiler: ‘class std::vector &gt;’ has no member named ‘emplace_back’ - c++ How to force g++ to compile c++11 standard only?]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCG第二次作业]]></title>
    <url>%2F2020%2F08%2F05%2FCCGhw-2%2F</url>
    <content type="text"><![CDATA[2020年暑假，顾险峰教授于线上讲授计算共形几何系列课程，本文记录了第二次作业的实现过程。本文框架： 代码环境配置； 代码补全思路。 代码环境配置代码环境配置与第一次相同 下载，解压，CMake代码； 补全 HarmonicMap.cpp 文件，并在 Xcode 中 build项目； 打开 Terminal，cd 至 /build/harmonic_map，输入 ./Debug/HarmonicMap ../../data/girl.m press ’h’, then press ’2’ 即可看到如下结果 Harmonic map of girl.m (细密网格) Harmonic map of boy.m (稀疏网格) 代码补全思路第二次作业要求补全 HarmonicMap.cpp 文件。 数据结构与第一次作业相同，HarmonicMapMesh.h 定义了适用于 HarmonicMap.cpp 的点、边、半边、面的子类，并仍使用原有名称。 代码补全思路采用两种方法得到曲面到单位圆盘上的调和映射（harmonic map）。第一种方法（Iterative Algorithm）基于调和函数的均值定理，首先将源曲面边界依据弧长大小影射到单位圆盘上，然后遍历源曲面上所有内点，根据与一点相邻各边的余切权重，不断调整该点影射后的位置，直至算法收敛；第二种方法（Direct Algorithm）直接离散 Laplace-Beltrami 算子（流形上的Laplace），这等价于求解一个稀疏的线性方程组。 值得注意的是，在编写第二种方法（函数 map() ）时，需要小心线性方程组中元素的正负号问题。计算效率上，第二种方法的计算速度明显优于第一种方法。]]></content>
      <categories>
        <category>Computational Conformal Geometry</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[C++大补丸2]]></title>
    <url>%2F2020%2F08%2F05%2FC%2B%2B%E5%A4%A7%E8%A1%A5%E4%B8%B82%2F</url>
    <content type="text"><![CDATA[编程小白在此整理一些C++基础知识。本文框架： 指针与引用 类和对象 函数模版 标准模版库（STL） 队列 指针与引用计算机中所有的数据都必须放在内存中，不同类型的数据占用的字节数不一样。为了正确地访问这些数据，必须为每个字节进行编号，我们将内存中字节的编号称为地址（Address）。我们可以通过&amp;a来访问变量a的地址。指针（pointer）可以理解为存储数据为内存地址的变量。定义方式： 1int a; int *p; p = &amp;a; 一个形象的比喻： 某天同学A说要学习C++，要借我的这本 C++ Primer Plus，我把书给A送过去发现A已经跑出去打篮球了，于是我把书放在了A桌子上书架的第三层四号的位置。并写了一张纸条：你要的书在第 三 层 四号的书架上。贴在A门上。当A回来时，看到这张纸条，A就知道了我借给他的书放在哪了。其实这张纸条就是一个指针了。它上面的内容不是书本身，而是书的地址，A通过纸条这个指针找到了我借给他的这本书。 我们知道，参数的传递本质上是一次赋值的过程，赋值就是对内存进行拷贝。所谓内存拷贝，是指将一块内存上的数据复制到另一块内存上。 对于像 char、bool、int、float 等基本类型的数据，它们占用的内存往往只有几个字节，对它们进行内存拷贝非常快速。而数组、结构体、对象等聚合类型，数据的数量没有限制，可能很少，也可能成千上万，对它们进行频繁的内存拷贝可能会消耗很多时间，拖慢程序的执行效率。 C/C++禁止在函数调用时直接传递数组的内容，而是强制传递数组指针。 在 C++ 中，我们有了一种比指针更加便捷的传递聚合类型数据的方式，那就是引用（reference）。引用可以看做是数据的一个别名，通过这个别名和原来的名字都能够找到这份数据。引用的定义方式类似于指针，只是用&amp;取代了*。 1int a; int &amp;r = a; 需要注意的是 引用必须在定义的同时初始化，并且以后也要从一而终，不能再引用其它数据； 引用在定义时需要添加&amp;，在使用时不能添加&amp;，使用时添加&amp;表示取地址。 在定义或声明函数时，我们可以将函数的形参指定为引用的形式，这样在调用函数时就会将实参和形参绑定在一起，让它们都指代同一份数据。如此一来，如果在函数体中修改了形参的数据，那么实参的数据也会被修改，从而拥有“在函数内部影响函数外部数据”的效果。 指针与引用实例：交换两个变量的值方法一：直接传递参数 12345678910111213141516#include &lt;iostream&gt;using namespace std;void swap1(int a,int b)&#123; int temp; temp = a; a = b; b = a;&#125;int main()&#123; int m = 1,n = 5; swap1(m,n); cout &lt;&lt; m &lt;&lt;", "&lt;&lt; n &lt;&lt; endl;&#125; 运行结果： 11, 5 方法二：传递指针 123456789101112131415#include &lt;iostream&gt;using namespace std;void swap2(int *a, int *b) &#123; int temp = *a; *a = *b; *b = temp;&#125;int main()&#123; int m = 1,n = 5; swap2(&amp;m,&amp;n); cout &lt;&lt; m &lt;&lt;", "&lt;&lt; n &lt;&lt; endl;&#125; 运行结果： 15, 1 方法三：按引用传参 123456789101112131415#include &lt;iostream&gt;using namespace std;void swap3(int &amp;a, int &amp;b) &#123; int temp = a; a = b; b = temp;&#125;int main()&#123; int m = 1,n = 5; swap3(m,n); cout &lt;&lt; m &lt;&lt;", "&lt;&lt; n &lt;&lt; endl;&#125; 运行结果： 15, 1 参考 [1] C/C++指针详解之基础篇 [2] C++引用 类和对象C++是一门面向对象的编程语言，理解 C++，首先要理解类（Class）和对象（Object）这两个概念。 C++ 中的类（Class）可以看做C语言中结构体（Struct）的升级版。类的成员不但可以是变量，还可以是函数，我们将类的成员变量称为属性（Property），将类的成员函数称为方法（Method）。定义一个类，本质上是定义一个数据类型的蓝图。这实际上并没有定义任何数据，但它定义了类的名称意味着什么，也就是说，它定义了类的对象包括了什么，以及可以在这个对象上执行哪些操作。对象可以通过类来创建，即将图纸生产成零件，这个过程叫做类的实例化，因此也称对象是类的一个实例（Instance）。 类是一个通用的概念，C++、Java、C#、PHP等很多编程语言中都支持类，都可以通过类创建对象。可以将类看做是结构体的升级版，C语言的晚辈们看到了C语言的不足，尝试加以改善，继承了结构体的思想，并进行了升级，让程序员在开发或扩展大中型项目时更加容易。因为 C++、Java、C#、PHP 等语言都支持类和对象，所以使用这些语言编写程序也被称为面向对象编程，这些语言也被称为面向对象的编程语言。C语言因为不支持类和对象的概念，被称为面向过程的编程语言。在C语言中，我们会把重复使用或具有某项功能的代码封装成一个函数，将拥有相关功能的多个函数放在一个源文件，再提供一个对应的头文件，这就是一个模块。使用模块时，引入对应的头文件就可以了。而在 C++ 中，多了一层封装，就是类（Class）。类由一组相关联的函数、变量组成，你可以将一个类或多个类放在一个源文件，使用时引入对应的类就可以。面向对象编程在代码执行效率上绝对没有任何优势，它的主要目的是方便程序员组织和管理代码，快速梳理编程思路，带来编程思想上的革新。 类成员函数类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。类成员函数是类的一个成员，它可以操作类的任意对象，可以访问对象中的所有成员。 类构造函数 &amp; 析构函数类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。 类的析构函数是类的一种特殊的成员函数，它会在每次删除所创建的对象时执行。析构函数的名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀，它不会返回任何值，也不能带有任何参数。析构函数有助于在跳出程序（比如关闭文件、释放内存等）前释放资源。 需要注意的是，有时构造函数后面会跟（:），这里冒号起分割作用，是类给成员变量赋值的方法，例如 1234class student&#123;student() : name("Tony") &#123;&#125;;&#125;; 类的继承面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。当创建一个类时，我们不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。 箭头运算C++中的箭头运算-&gt;，相当于把解指针和成员访问符两个操作结合在一起，即 p-&gt;func()等价于(*p).func()。 参考 [1] C++类和对象到底是什么意思？ [2] C++ 类 &amp; 对象 函数模版（Template）所谓函数模板，实际上是建立一个通用函数，它所用到的数据的类型（包括返回值类型、形参类型、局部变量类型）可以不具体指定，而是用一个虚拟的类型来代替（实际上是用一个标识符来占位），等发生函数调用时再根据传入的实参来逆推出真正的类型。这个通用函数就称为函数模板（Function Template）。 在函数模板中，数据的值和类型都被参数化了，发生函数调用时编译器会根据传入的实参来推演形参的值和类型。换个角度说，函数模板除了支持值的参数化，还支持类型的参数化。 一但定义了函数模板，就可以将类型参数用于函数定义和函数声明了。说得直白一点，原来使用 int、float、char 等内置类型的地方，都可以用类型参数来代替。模版的一般语法为 1234template &lt;typename 类型参数1 , typename 类型参数2 , ...&gt; 返回值类型 函数名(形参)&#123; //在函数体中可以使用类型参数&#125; 在上面“交换两个变量的值”的例子中，方法三可以改写为： 1234567891011121314151617#include &lt;iostream&gt;using namespace std;template&lt;typename T&gt; void swap3(T &amp;a, T &amp;b)&#123; T temp = a; a = b; b = temp;&#125;int main()&#123; int m = 1,n = 5; float a = 0.1, b = 0.5; swap3(m,n); swap3(a,b); cout &lt;&lt; m &lt;&lt;", "&lt;&lt; n &lt;&lt; endl; cout &lt;&lt; a &lt;&lt;", "&lt;&lt; b &lt;&lt; endl;&#125; 运行结果： 125, 10.5, 0.1 参考 [1] C++函数模板5分钟入门教程 标准模版库（STL）STL 是“Standard Template Library”的缩写，中文译为“标准模板库”或者“泛型库”。STL 是 C++ 标准库的一部分，不用单独安装。C++ 对模板（Template）支持得很好，STL 就是借助模板把常用的数据结构及其算法都实现了一遍，并且做到了数据结构和算法的分离。例如，vector 的底层为顺序表（数组），list 的底层为双向链表，deque 的底层为循环队列，set 的底层为红黑树，hash_set 的底层为哈希表。因此可以说，STL 基本上达到了各种存储方法和相关算法的高度优化。 通常认为，STL是由容器、算法、迭代器、函数对象、适配器、内存分配器这 6 部分构成，其中后面 4 部分是为前 2 部分服务的。 容器：一些封装数据结构的模板类，例如 vector 向量容器、list 列表容器等。 算法：STL 提供了非常多（大约 100 个）的数据结构算法，它们都被设计成一个个的模板函数，这些算法在 std 命名空间中定义，其中大部分算法都包含在头文件&lt;algorithm&gt; 中，少部分位于头文件&lt;numeric&gt; 中。 迭代器：在 C++ STL 中，对容器中数据的读和写，是通过迭代器完成的，扮演着容器和算法之间的胶合剂。 函数对象：如果一个类将 () 运算符重载为成员函数，这个类就称为函数对象类，这个类的对象就是函数对象（又称仿函数）。 适配器：可以使一个类的接口（模板的参数）适配成用户指定的形式，从而让原本不能在一起工作的两个类工作在一起。值得一提的是，容器、迭代器和函数都有适配器。 内存分配器：为容器类模板提供自定义的内存申请和释放功能，由于往往只有高级用户才有改变内存分配策略的需求，因此内存分配器对于一般用户来说，并不常用。 容器容器简单来说就是一些模板类的集合，但和普通模板类不同的是，容器中封装的是组织数据的方法（也就是数据结构）。STL 提供有 3 类标准容器，分别是序列容器、排序容器和无序关联式容器（哈希容器），其中后两类容器有时也统称为关联容器。 序列容器：主要包括array容器（简单来说，它就是在 C++ 普通数组的基础上，添加了一些成员函数和全局函数） vector 向量容器、list 列表容器以及 deque 双端队列容器。之所以被称为序列容器，是因为元素在容器中的位置同元素的值无关，即容器不是排序的。将元素插入容器时，指定在什么位置，元素就会位于什么位置。 排序容器：包括 set 集合容器、multiset多重集合容器、map映射容器以及 multimap 多重映射容器。排序容器中的元素默认是由小到大排序好的，即便是插入元素，元素也会插入到适当位置。所以关联容器在查找时具有非常好的性能。 哈希容器：C++11 新加入 4 种关联式容器，分别是 unordered_set 哈希集合、unordered_multiset 哈希多重集合、unordered_map 哈希映射以及 unordered_multimap 哈希多重映射。和排序容器不同，哈希容器中的元素是未排序的，元素的位置由哈希函数确定。 以上 3 类容器的存储方式完全不同，因此使用不同容器完成相同操作的效率也大不相同。所以在实际使用时，要善于根据想实现的功能，选择合适的容器。 迭代器尽管不同容器的内部结构各异，但它们本质上都是用来存储大量数据的，换句话说，都是一串能存储多个数据的存储单元。因此，诸如数据的排序、查找、求和等需要对数据进行遍历的操作方法应该是类似的。既然类似，完全可以利用泛型技术，将它们设计成适用所有容器的通用算法，从而将容器和算法分离开。但实现此目的需要有一个类似中介的装置，它除了要具有对容器进行遍历读写数据的能力之外，还要能对外隐藏容器的内部差异，从而以统一的界面向算法传送数据。这是泛型思维发展的必然结果，于是迭代器就产生了。简单来讲，迭代器和 C++ 的指针非常类似，它可以是需要的任意类型，通过迭代器可以指向容器中的某个元素，如果需要，还可以对该元素进行读/写操作。 STL 标准库为每一种标准容器定义了一种迭代器类型，这意味着，不同容器的迭代器也不同，其功能强弱也有所不同。常用的迭代器按功能强弱分为输入迭代器、输出迭代器、前向迭代器、双向迭代器、随机访问迭代器 5 种。 前向迭代器（forward iterator）：假设 p 是一个前向迭代器，则 p 支持 ++p，p++，*p 操作，还可以被复制或赋值，可以用 == 和 != 运算符进行比较。此外，两个正向迭代器可以互相赋值。例如，容器 forward_list，unordered_map / unordered_multimap，unordered_set / unordered_multiset 就采用该迭代器。 双向迭代器（bidirectional iterator）：双向迭代器具有正向迭代器的全部功能，除此之外，假设 p 是一个双向迭代器，则还可以进行 —p 或者 p— 操作（即一次向后移动一个位置）。例如，容器 list，set / multiset，map / multimap 就采用该迭代器。 随机访问迭代器（random access iterator）：随机访问迭代器具有双向迭代器的全部功能。除此之外，假设 p 是一个随机访问迭代器，i 是一个整型变量或常量，则 p 还支持以下操作： p+=i：使得 p 往后移动 i 个元素。 p-=i：使得 p 往前移动 i 个元素。 p+i：返回 p 后面第 i 个元素的迭代器。 p-i：返回 p 前面第 i 个元素的迭代器。 p[i]：返回 p 后面第 i 个元素的引用。 此外，两个随机访问迭代器 p1、p2 还可以用 &lt;、&gt;、&lt;=、&gt;= 运算符进行比较。另外，表达式 p2-p1 也是有定义的，其返回值表示 p2 所指向元素和 p1 所指向元素的序号之差（也可以说是 p2 和 p1 之间的元素个数减一）。例如，容器 array，vector，deque 就采用该迭代器。 其实在 C++ 中，数组也是容器。数组的迭代器就是指针，而且是随机访问迭代器。例如，对于数组 int a[10]，int * 类型的指针就是其迭代器。尽管不同容器对应着不同类别的迭代器，但这些迭代器有着较为统一的定义方式，例如 ， 正向迭代器：容器类名::iterator 迭代器名 ； 反向迭代器：容器类名::reverse_iterator 迭代器名。 适配器容器适配器容器适配器中的“适配器”，和生活中常见的电源适配器中“适配器”的含义非常接近。我们知道，无论是电脑、手机还是其它电器，充电时都无法直接使用 220V 的交流电，为了方便用户使用，各个电器厂商都会提供一个适用于自己产品的电源线，它可以将 220V 的交流电转换成适合电器使用的低压直流电。从用户的角度看，电源线扮演的角色就是将原本不适用的交流电变得适用，因此其又被称为电源适配器。 容器适配器也是同样的道理，容器适配器是一个封装了序列容器的类模板，它在一般序列容器的基础上提供了一些不同的功能。之所以称作适配器类，是因为它可以通过适配容器现有的接口来提供不同的功能。容器适配器本质上还是容器，只不过此容器模板类的实现利用了大量其它基础容器模板类中已经写好的成员函数。STL 提供了 3 种容器适配器，分别为 stack 栈适配器、queue 队列适配器以及 priority_queue 优先权队列适配器。通常情况下，使用默认的基础容器即可。 迭代器适配器本质上讲，迭代器适配器仍属于迭代器，可以理解为是基础迭代器的“翻新版”或者“升级版”。初学者完全可以将迭代器适配器视为普通迭代器。之所以称为迭代器适配器，是因为这些迭代器是在输入迭代器、输出迭代器、正向迭代器、双向迭代器或者随机访问迭代器这些基础迭代器的基础上实现的。也就是说，使用迭代器适配器的过程中，其本质就是在操作某种基础迭代器。 算法STL中常用的算法可以参考这里。 参考 [1] STL教程：C++ STL快速入门 队列许多程序都使用了 queue 容器。queue 容器可以用来表示超市的结账队列或服务器上等待执行的数据库事务队列。 queue的基本操作： front()：返回 queue 中第一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。 back()：返回 queue 中最后一个元素的引用。如果 queue 是常量，就返回一个常引用；如果 queue 为空，返回值是未定义的。 push(const T&amp; obj)：在 queue 的尾部添加一个元素的副本。这是通过调用底层容器的成员函数 push_back() 来完成的。 push(T&amp;&amp; obj)：以移动的方式在 queue 的尾部添加元素。这是通过调用底层容器的具有右值引用参数的成员函数 push_back() 来完成的。 pop()：删除 queue 中的第一个元素。 size()：返回 queue 中元素的个数。 empty()：如果 queue 中没有元素的话，返回 true。 queue没有迭代器。访问元素的唯一方式是遍历容器内容，并移除访问过的每一个元素。 参考 [1] C++ queue(STL queue)用法详解]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++大补丸1]]></title>
    <url>%2F2020%2F07%2F24%2FC%2B%2B%E5%A4%A7%E8%A1%A5%E4%B8%B81%2F</url>
    <content type="text"><![CDATA[编程小白在此整理一些C++基础知识。本文框架： C++与C语言关系 编译过程 GCC和LLVM Xcode 工程结构 CMake C++与C语言关系顾名思义，C++ 是在C语言的基础上增加新特性。从语法上看，C语言是 C++ 的一部分，C语言代码几乎不用修改就能够以 C++ 的方式编译。 发展历史早期并没有“C++”这个名字，而是叫做“带类的C”。“带类的C”是作为C语言的一个扩展和补充出现的，它增加了很多新的语法，目的是提高开发效率。这个时期的 C++ 非常粗糙，仅支持简单的面向对象编程，也没有自己的编译器，而是通过一个预处理程序（名字叫 cfront），先将 C++ 代码”翻译“为C语言代码，再通过C语言编译器合成最终的程序。 随着 C++ 的流行，它的语法也越来越强大，已经能够很完善的支持面向过程编程、面向对象编程（OOP）和泛型编程，几乎成了一门独立的语言，拥有了自己的编译方式。 C与 C++ 在很多平台下有拥有共同的编译器，例如 Windows 下的微软编译器（cl.exe）、Linux 下的 GCC编译器、Mac 下的 Clang 编译器（已经是 Xcode 默认编译器，雄心勃勃，立志超越 GCC），它们都同时支持C语言和 C++，统称为 C/C++ 编译器。对于C语言代码，它们按照C语言的方式来编译；对于 C++ 代码，就按照 C++ 的方式编译。 参考 [1] C语言中文网 编译过程整个编译过程分为两大步： 编译 ：编译器对源代码进行编译，把文本形式的源代码翻译成机器语言，并形成目标文件； 连接 ：把目标文件操作系统的启动代码和库文件组织起来形成可执行程序。 在一个 C++ 程序中，常包含两类文件—— .cpp 文件和 .h 文件。其中，.cpp 文件被称作 C++ 源文件；而 .h 文件则被称作 C++ 头文件。 源文件（Source File）在开发软件的过程中，我们需要将编写好的代码保存到一个文件中，这样代码才不会丢失，才能够被编译器找到，才能最终变成可执行文件。这种用来保存代码的纯文本文件就叫做源文件，它的内部并没有特殊格式。 C语言源文件的后缀是.c； C++语言（C Plus Plus）源文件的后缀是.cpp； Java源文件的后缀是.java； Python源文件的后缀是.py； JavaScript源文件后置是.js。 需要注意的是，不同的编译器支持不同的C++ 源文件后缀，这里进行了简单的汇总。 头文件（Head File）所谓的头文件，其实它的内容跟 .cpp 文件中的内容是一样的，都是 C++ 的源代码。但头文件不用被编译。我们把所有的函数声明全部放进一个头文件中，当某一个 .cpp 源文件需要它们时，它们就可以通过一个宏命令 “#include” 包含进这个 .cpp 文件中，从而把它们的内容合并到 .cpp 文件中去。当 .cpp 文件被编译时，这些被包含进去的 .h 文件的作用便发挥了。应该记住的一点就是，.h头文件中，只能存在变量或者函数的声明，而不要放定义。 .h文件中能包含： 类成员数据的声明，但不能赋值 类静态数据成员的定义和赋值，但不建议，只是个声明就好。 类的成员函数的声明 非类成员函数的声明 常数的定义：如：const int a=5; 静态函数的定义 类的内联函数（inline）的定义 .h文件中不能包含： 所有非静态变量（不是类的数据成员）的声明 默认命名空间声明不要放在头文件，using namespace std;等应放在.cpp中，在 .h 文件中使用 std::string 编译编译过程细分为三个阶段：预编译—&gt;编译优化—&gt;汇编。 预编译：预处理又称为预编译，是做些代码文本替换工作。编译器执行预处理指令（以#开头，例如#include），这个过程会得到不包含#指令的.i文件。这个过程会拷贝#include 包含的文件代码，进行#define 宏定义的替换 ， 处理条件编译指令 （#ifndef #ifdef #endif）等。 编译、优化：预编译输出的.i文件中，只有常量：数字、字符串、变量的定义，以及c语言的关键字：main、if、else、for、while等。编译程序所要作得工作就是通过词法分析和语法分析，在确认所有的指令都符合语法规则之后，将其翻译成等价的中间代码表示或汇编代码。优化处理是编译系统中一项比较艰深的技术，其工作主要是，通过语法分析和词法分析，确定所有指令是否符合规则。这个过程将.i文件转化位.s文件。 汇编：汇编过程就是把汇编语言翻译成目标机器指令的过程，生成目标文件（.obj .o等）。目标文件中存放的也就是与源程序等效的目标的机器语言代码。目标文件由段组成，通常至少有两个段： 代码段：包换主要程序的指令。该段是可读和可执行的，一般不可写。 数据段：存放程序用到的全局变量或静态数据。可读、可写、可执行。 这个过程将.s文件转化成.o文件。 链接（Link）C++ 语言支持”分别编译”（separate compilation）。也就是说，一个程序所有的内容，可以分成不同的部分分别放在不同的 .cpp 文件里。.cpp 文件里的东西都是相对独立的，在编译（compile）时不需要与其他文件互通，只需要在编译成目标文件后再与其他的目标文件做一次链接（link）就行了。比如，在文件 a.cpp 中定义了一个全局函数 “void a(){}”，而在文件 b.cpp 中需要调用这个函数。即使这样，文件 a.cpp 和文件 b.cpp 并不需要相互知道对方的存在，而是可以分别地对它们进行编译，编译成目标文件之后再链接，整个程序就可以运行了。 这是怎么实现的呢？从写程序的角度来讲，很简单。在文件 b.cpp 中，在调用 “void a()” 函数之前，先声明一下这个函数 “voida();”，就可以了。这是因为编译器在编译 b.cpp 的时候会生成一个符号表（symbol table），像 “void a()” 这样的看不到定义的符号，就会被存放在这个表中。再进行链接的时候，编译器就会在别的目标文件中去寻找这个符号的定义。一旦找到了，程序也就可以顺利地生成了。链接过程将.o文件转化成可执行的文件（.exe、.elf、.axf等）。 值得注意的是，这里提到了两个概念，一个是”定义”，一个是”声明”。简单地说，”定义”就是把一个符号完完整整地描述出来：它是变量还是函数，返回什么类型，需要什么参数等等。而”声明”则只是声明这个符号的存在，即告诉编译器，这个符号是在其他文件中定义的，我这里先用着，你链接的时候再到别的地方去找找看它到底是什么吧。定义的时候要按 C++ 语法完整地定义一个符号（变量或者函数），而声明的时候就只需要写出这个符号的原型了。需要注意的是，一个符号，在整个程序中可以被声明多次，但却要且仅要被定义一次。 编译与链接过程示意图 参考 [1] C语言中文网 [2] 菜鸟教程 [3] [C/C++程序编译过程详解] GCC 和 LLVM Mac 下，如果你安装了 Xcode ，那么你就拥有了 LLVM 和 GCC 两大编译工具。 LLVMLLVM，原来叫做 「Low Level Virtual Machine」，该项目的领导者和最初作者是 Chris Lattner 和 Vikram Adve，在 2000年的开始于 伊利诺伊大学厄巴纳-香槟分校（University of Illinois at Urbana-Champaign），2005年，Apple 雇佣了 Chris Lattner，成立了一个团队专注于 LLVM 系统在 Apple 开发系统上的各种使用。LLVM 目前是 Apple 的 Mac OSX 和 iOS 的开发工具的重要部分。LLVM 项目是一个综合项目（umbrella project），它包括了一系列开发工具相关的技术，如： 编译器，Clang，LLVM 原生的 C/C++/Objective-C 编译器，旨在提供一个快速的编译器 调试器，LLDB，在 LLVM 和 Clang 的基础上构建的一个调试器 JIT 系统，VMKit， Java 和 .NET 虚拟机的 LLVM 技术实现 优化器，DragonEgg，集成了 LLVM 的优化器和搭配 GCC 解析工具的代码产生器 …… GCCGCC，全称为 GNU Complier Collection，GCC 是 GNU Project 的关键组成部分，是由自由软件之父 Richard Stallman 在 1983 年9月27日于麻省理工大学发起的，旨在给一切计算机用户提供自由、可控的计算环境，用户可以自由的运行、分享、学习以及修改软件，即自由软件。 GCC 最初叫做 GNU C Compiler ，只支持 C 语言的编译，1.0 之后开始支持 C++，再随后支持了 Objective-C，Objective-C++，Fortran，Java，Ada，Go等其他语言。至于选择哪个作为首选，则看具体情况了。GCC 历史悠久，支持较为广泛，且目前许多开源项目都是直接使用 GCC 作为编译器的。当然，Clang 同为开源项目，可以跨平台使用，而 Clang 相对 GCC 的优势： 编译速度快：在某些平台上，Clang 的编译速度显著的快过 GCC。 占用内存小：Clang 生成的 AST 所占用的内存是 GCC 的五分之一左右。 模块化设计：Clang 采用基于库的模块化设计，易于 IDE 集成及其他用途的重用。 诊断信息可读性强：在编译过程中，Clang 创建并保留了大量详细的元数据 (metadata)，有利于调试和错误报告。 设计清晰简单，容易理解，易于扩展增强。与代码基础古老的 GCC 相比，学习曲线平缓。 参考 [1] Mac 下的 C++ 开发环境 Xcode 工程结构工程／项目（Project）一个真正的程序（也可以说软件）往往包含多项功能，每一项功能都需要几十行甚至几千行、几万行的代码来实现。在实际开发中，程序员都是将这些代码分门别类地放到多个源文件中。除了这些成千上万行的代码，一个程序往往还要包含图片、视频、音频、控件、库（也可以说框架）等其它资源，它们也都是一个一个地文件。 为了有效地管理这些种类繁杂、数目众多的文件，我们有理由把它们都放到一个目录（文件夹）下，并且这个目录下只存放与当前程序有关的资源。实际上 IDE 也是这么做的，它会为每一个程序都创建一个专门的目录，将用到的所有文件都集中到这个目录下，并对它们进行便捷的管理，比如重命名、删除文件、编辑文件等。 这个为当前程序配备的专用文件夹，被称做“Project”。 工程／项目类型“程序”是一个比较宽泛的称呼，它可以细分为很多种类，例如： 有的程序不带界面，完全是“黑屏”的，只能输入一些字符或者命令，称为控制台程序（Console Application），例如 Windows 下的 cmd.exe，Linux 或 Mac OS 下的终端（Terminal）。 有的程序带界面，看起来很漂亮，能够使用鼠标点击，称为GUI程序（Graphical User Interface Program），例如 QQ、Chrome 等。 有的程序不单独出现，而是作为其它程序的一个组成部分，普通用户很难接触到它们，例如静态库、动态库等。 控制台程序是 DOS 时代的产物了，它没有复杂的功能，没有漂亮的界面，只能看到一些文字，虽然枯燥无趣，也不实用，但是它非常简单，不受界面的干扰，所以适合入门。 不同的程序对应不同的工程类型（项目类型），使用 IDE 时必须选择正确的工程类型才能创建出我们想要的程序。换句话说，IDE 包含了多种工程类型，不同的工程类型会创建出不同的程序。不同的工程类型本质上是对 IDE 中各个参数的不同设置；我们也可以创建一个空白的工程类型，然后自己去设置各种参数（不过一般不这样做）。 Scheme、Target、Project 和 WorkspaceScheme、Target、Project 和 Workspace 是组成一个 Xcode 工程最核心的单元。 TargetTarget 是工程中的最小可编译单元，每一个 target 对应一个编译输出，这个输出可以是一个链接库，一个可执行文件或者一个资源包。它定义了这个输出怎样被 build 的所有细节，包括： 编译选项，比如使用的编译器，目标平台，flag，头文件搜索路径等等。 哪些源码或者资源文件会被编译打包，哪些静态库、动态库会被链接。 build 时的前置依赖、执行的脚本文件。 build 生成目标的签名、Capabilities 等属性。 我们平时在 Build Settings，Build Phases 中配置的各种选项，大部分都是对应到指定的 target 的。每次我们在 Xcode 中 run/test/profile/analyze/archive 时，都必须指定一个 target。工程中的 targets 有时候会共享很多代码、资源，这些相似的 targets 可能对应同一个应用的不同版本，比如 iPad 版和 iPhone 版，或者针对不同市场的版本。 Scheme当点击Xcode 左上角的 Run 箭头来运行调试代码，这其实就是执行了 Scheme 定义的一个任务。针对一个指定的 target，scheme 定义了 build 这个 target 时使用的配置选项，执行的任务，环境参数等等。Scheme 可以理解为一个工作流，或者蓝图，当我们点击 debug，test 按钮时，Xcode 会按照 scheme 中的定义，去执行对应的工作流。 Scheme 中预设了六个主要的工作流： Build, Run, Test, Profile, Analyze, Archive。包括了我们对某个 target 的所有操作，每一个工作流都可以单独配置。Scheme 中最重要的一个配置是选择 target 的 build configuration，对每一个 project，会有两个默认的 build configuration：debug 和 release。每个 configuration 对应了 build target 时不同的参数集，比如宏，编译器选项，bundle name 等等。我们可以在 target 的配置页中更改这些选择项，也可以自己创建新的 build configuration。除了 build configuration 外，scheme 还可以配置： 运行时的环境变量（Environment Variables） 启动时设置给 UserDefaults 的参数（Arguments Passed on Launch） App 执行时的系统语言、模拟的定位坐标、国家等环境参数 runtime，内存管理，日志，帧率检测等调试选项 另外有一些 debug 时十分有用的选项，也可以在 scheme 配置中找到。一个 scheme 对应一个 target，同一个 target 可以有多个 scheme，通过灵活地配置 scheme，我们可以方便地管理不同环境下项目的测试，调试，打包流程。 ProjectProject 很好理解，就是一个 Xcode 工程，它管理这个工程下的 targets 集合以及它们的源码，引用的资源，framework 等等。 Project 是管理资源的容器，本身是无法被编译的，所以每个 project 至少应该有一个可编译的 target，否则就是一个空壳。一个 target 编译时引用的资源是它所在 project 所有管理资源的子集。 我们也可以对 project 进行配置，包括基本信息和编译选项（Build Settings）等，这些配置会应用到它管理的所有 targets 中，但是如果 target 有自己的配置，则会覆盖 project 中对应的配置。在很多情况下，我们的工程中只有一个 project。可以在 finder 中双击后缀名为.xcodeproj 的文件，就可以直接打开单个 project 了。 如果我们需要从源码编译一个依赖库，可以把这些源码所在的工程作为主工程的subProject 添加到目录结构中去，然后将这个子工程的某个 target 作为主工程 target 的依赖，从而在 build 主工程 target 的时候，顺便也会编译子工程对应的 target。这样做的好处是你可以在一个窗口中同时修改主工程和子工程的源码，并且一起进行编译。 Workspace上面所说的添加子工程的方法，已经很好的解决了不同项目中 target 依赖的问题了，那么什么时候需要用到 Workspace 呢？事实上，当一个 target 被多个不同的项目依赖，或者 project 之间互相引用，那么我们就需要把这些 projects 放到相同的层级上来。管理相同层级 projects 的容器就是 Workspace。和 projects，target 不同，workspace 是纯粹的容器，不参与任何编译链接过程，它主要管理： Xcode 中的 projects，记录它们在 Finder 中的引用位置。 一些用户界面的自定义信息（窗口的位置，顺序，偏好等等）。 注意到，当你把不同的 projects 放到一个 workspace 中管理后，你仍然可以用 Xcode 单独打开其中的某一个 project，但是如果它涉及到对其它 project target 的依赖，这时候你无法在这个单独的窗口中编译成功。在大多数情况下project就足够了，除非有特殊情况否则不要使用workspace。事实上，我们总是可以在需要的时候将project嵌入workspace。 Project目录结构策略（该部分参考这个知乎回答）可以先按 MVC、工具和第三方库 划分成为顶层目录，再根据各自的特性划分二级甚至三级目录，但一般不超过三级。 ThirdParty （第三方类 / 库） |- UMessage |- UMessage.h |- … |- UMAnalytics |- … Utils （工具类） |-Network（网络工具，比如 HTTP、Socket 封装等） |- UI（UI 工具，封装一些动画等） |- FLUIUtils.h |- FLUIUtils.m |- … |- … Models （模型 M） |- ModelUtils（仅用于模型的工具） |- LocalStorage（本地存取封装） |- ZFSystem（特定功能相关，内容分析等） |- xxx.h |- xxx.m |- MessageBoard（留言板） |- … ViewControllers （VC） |- Login（登录页） |- ZQVCLogin.h |- ZQVCLogin.m |- ZQVCLogin.xib（这个 App 写得比较早，所以还在用 xib） |- User（用户信息页） |- Library（图书馆功能页） |- Score（查分页） |- About（关于页） |- … res （资源） |- common（通用资源） |- xxx.png |- animations |- login |- … 参考 [1] iOS 开发：深入理解 Xcode 工程结构（一） [2] Xcode Concepts [3] Xcode Project vs. Xcode Workspace - Differences [4] 开发较复杂的 iOS 应用时，在建立清晰易懂的项目目录结构这方面，你有什么好的经验或心得？ CMakeCMake是一个构建系统生成器（build-system generator）。常见的构建系统，有Visual Studio，XCode，Make等等。CMake可以支持不同平台下构建系统的生成。 gcc是GNU Compiler Collection（就是GNU编译器套件），也可以简单认为是编译器，它可以编译很多种编程语言（括C、C++、Objective-C、Fortran、Java等等）。当你的程序只有一个源文件时，直接就可以用gcc命令编译它。但是当你的程序包含很多个源文件时，用gcc命令逐个去编译时，你就很容易混乱而且工作量大所以出现了make工具。 make工具可以看成是一个智能的批处理工具，它本身并没有编译和链接的功能，而是用类似于批处理的方式——通过调用makefile文件中用户指定的命令来进行编译和链接的。makefile是什么？简单的说就像一首歌的乐谱，make工具就像指挥家，指挥家根据乐谱指挥整个乐团怎么样演奏，make工具就根据makefile中的命令进行编译和链接的。makefile命令中就包含了调用gcc（也可以是别的编译器）去编译某个源文件的命令。makefile在一些简单的工程完全可以人工手下，但是当工程非常大的时候，手写makefile也是非常麻烦的，如果换了个平台makefile又要重新修改。这时候就出现了CMake（Cross platform Make）这个工具，cmake就可以更加简单的生成makefile文件给上面那个make用。cmake是个一个开源的跨平台自动化建构系统，用来管理软体建置的程序，并不依赖于某特定编译器，并可支援多层目录、多个应用程式与多个函式库。可是cmake根据什么生成makefile呢？它又要根据一个叫CMakeLists.txt文件（学名：组态档）去生成makefile。CMakeLists.txt文件可以自己手写也可以利用IDE直接生成。 参考 [1] GCC 和 cmake的关系？ [2] CMake]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CCG第一次作业]]></title>
    <url>%2F2020%2F07%2F24%2FCCGhw-1%2F</url>
    <content type="text"><![CDATA[2020年暑假，顾险峰教授于线上讲授计算共形几何系列课程，本文记录了第一次作业的实现过程。本文框架： 代码环境配置； 代码补全思路。 代码环境配置 下载第一次作业代码SkeletonCode，下载CMakeGUI并通过“Tools—&gt;How to Install For Command Line Use” 安装CMake； 解压第一次作业代码，在“CCGHomework_skeleton”中新建文件夹“build”； 打开CMakeGUI，“source code” 选择“CCGHomework_skeleton”所在目录，“build the binaries” 选择“CCGHomework_skeleton/build”，点击Generate，并选择Xcode项目； 生成后打开Xcode项目，Build该项目（或Command+B），此时可以发现在“CCGHomework_skeleton/build/cutgraph/Debug”中生成了一个执行文件； 打开Terminal，cd至“CCGHomework_skeleton/build/cutgraph”，输入“./Debug/CutGraph ../../data/eight.m”即可看到初始三角网格； 补全“CCGHomework_skeleton/cutgraph/src”中的“CutGraph.cpp”文件，重复步骤4和5即可看到如下所示的CutGraph； Cut graph of eight.m 代码补全思路火烧法通过模拟火在曲面上燃烧来得到 Cut Graph，进而得到基本群的生成元。第一次作业要求补全“CutGraph.cpp”文件。 数据结构 “MeshLib/core/Mesh/BaseMesh.h”中给出了三角网格的数据结构“class CBaseMesh”并定义了一些网格中点、边、半边、面的Method； “MeshLib/core/Mesh/Iterators.h”中给出了“Face到Edge”，“Face到HalfEdge”，“Mesh到Edge”，“Mesh到Face”……的迭代器（迭代器相比数组的好处是速度快，缺点是无法直接索引，因此会设置一些flag来锁定元素）； “cutgraph/include/CutGraphMesh.h”中定义的“CCutGraphEdge”，“CCutGraphFace”，“CCutGraphVertex”，“CCutGraphHalfEdge”是class CBaseMesh 的点、边、半边、面的子类，增添了一些flag。 代码补全思路我们通过函数“cut_graph()”得到CutGraph。该函数首先通过函数“_dual_spanning_tree()”得到对偶图中的生成树，然后将Edge上的“sharp”标记取反，此时“sharp==true”的那些边将组成最终的Cut Graph。注意到，“sharp==true”的边组成的图会包含一些“叶子”，我们利用函数“_prune()”剪去这些“叶子”。 函数“_dual_spanning_tree()”利用贪心算法得到对偶图中的生成树。思路如下： 初始化：通过MeshEdgeIterator和MeshFaceIterator遍历三角网格中的边和面，并将它们的flag置为false。 贪心算法：构造一个CutGraphFace*的队列，任取一个flag为false的Face放入队列并将面的flag置为true，通过FaceHalfedgeIterator遍历该Face的HalfEdge，若某HalfEdge的对称HalfEdge非Null则找到这个对称HalfEdge所在Face，将该Face放入队列并将HalfEdge所在边的flag置为true，重复上述步骤。 函数“_prune()”通过在Vertex结构中引入valence标记进行剪枝。思路如下： 初始化：首先将Vertex的valence置为0，若Vertex对应边的flag==true，则valence++。将所有valence==1的Vertex放入一个CCutGraphVertex*队列。 剪枝：遍历队列，找到flag==true的Edge上的另一个Vertex，在队列中删除当前Vertex，加入该Vertex并valence—，将此Edge的flag置为false。]]></content>
      <categories>
        <category>Computational Conformal Geometry</category>
      </categories>
      <tags>
        <tag>CCG环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Blog导读]]></title>
    <url>%2F2019%2F03%2F14%2FBlog%E5%AF%BC%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[这是博客中的第一篇文章，在这里我将介绍： 开博客的目的 博文的整体框架。 开博客目的这个Blog将大致分为：“生活”、“学习”、“科研” 三大部分。其中，“生活” 部分将主要记录一些旅游和个人感悟；“学习” 部分将主要用于记录和整理一些课上笔记或者自学内容；“科研” 部分将介绍一些本领域内有趣的paper。]]></content>
      <tags>
        <tag>导读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo+Github搭建Blog]]></title>
    <url>%2F2019%2F03%2F14%2FBlog%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[本文将简略介绍利用Github和Hexo搭建本地Blog的方法。需要注意，请按照文中各部分给出的链接进行搭建，以免踩坑。本文框架为： 基本准备； 搭建流程； 配置Hexo完善Blog； 发布／删除文章。 基本准备 申请一个Github账号，并以.github.io命名一个公开的repo； 在电脑上安装git、Node.js之后安装Hexo，参见Hexo官网。 搭建流程 初始化Hexo，尝试Hexo基本操作，并编写第一篇文章，详细过程参见Division By Zero； 装载新主题NexT（此过程中请务必在Blog根目录下进行）； 发布文章到网上，并添加SSH KEY，参见Division By Zero（请注意区分Blog目录下的“_config.yml”和themes/next下的“_config.yml”）； 配置NexT主题，添加个性化功能，例如：主题风格、搜索服务、添加标签、添加分类、评论功能等。 配置Hexo完善Blog对数学公式的支持Hexo博客主要基于Markdown语言，而在Markdown语言中输入数学公式一个比较好的方法是使用MathJax引擎。为了使博客支持MathJax，我们需要配置Hexo渲染MathJax中的数学公式，参见简书教程和Hexo博客使用MathJax。 插一句题外话，本地Markdown编译器我强烈推荐 Typora（手感顺滑，功能强大，开源），在线Markdown编译器我推荐StackEdit（可关联Github账号）。 MathJax中的语法类似Tex，一些基本的语法参见MathJax(Markdown中的公式)的基本使用语法。 对图片支持有时候博文中会配有图片或动图，因此我需要一个与md文件同名的文件夹来存放他们。这部分请参看Division By Zero。（需要注意，插入图片时图片地址应为“同名文件夹/image.jpeg”） 对流程图支持在Markdown中使用mermaid包，我们可以非常容易地画出流程图和顺序图。为了将这种方便延续到博客的写作中，我们需要配置Hexo来支持mermaid包。具体做法请参考TY·Loafer和hexo-filter-mermaid-diagrams。其中，TY·Loafer的代码有些问题，请同时参考上面两个链接中的方法，并使用后者提供的代码。 文章置顶及折叠要使文章置顶，需要装载新的Hexo模块并修改next中的设置，参见Hexo文章置顶。 要使文章折叠，可以在md文件的导语和正文之间添加：1&lt;!-- more --&gt; md文件的一般格式如下：123456789101112---title: XXXdate: 20XX-XX-XXtags: categories: mathjax: (是否使用MathJax)top: （文章是否置顶）copyright: true---（导语）&lt;!-- more --&gt;（正文） 可以在/scaffolds/post.md文件中修改好上述默认格式，之后每一次$ hexo new即可。 添加统计功能NexT主题中自带的busuanzi功能可以实现访客数与浏览数统计，参见Hexo使用不蒜子统计功能。 增加版权信息自己的劳动成果当然不想被他人窃取，在文章末尾添加版权信息是一种不错的保护自己的手段。参见hexo的next主题个性化配置教程之20。 文章加密访问有些私密文章，设置一些密码也是必须的。这里有两个参考教程：hexo的next主题个性化配置教程之20和Hexo文章简单加密访问。根据第二个教程，建议将代码放在所有的&lt;meta&gt;标签之后。 发布/删除文章发布文章将写好的Markdown文件拖入/Blog/source/_posts/，之后在当前目录下运行12$ hexo generate $ hexo server（生成本地预览） 删除文章在/Blog/source/_posts/中删除相关文件，之后运行123$ hexo clean $ hexo generate $ hexo server（生成本地预览） 草稿功能有时候想在网站中删除相关文章，而不删除相关Markdown文件，可以将此文件存入到“草稿”中。 创建草稿1$ hexo new draft &lt;title&gt; 这时，草稿将被保存在/Blog/source/_drafts/当中。 预览草稿草稿中的文件不会出现在网页中，但可以通过一下命令进行预览。1$ hexo server --draft 发布草稿运行以下代码，可将草稿中的文件移动到/Blog/source/_posts/当中。1$ hexo publish &lt;title&gt; 最后运行1$ hexo deploy 将文章部署到Github个人网站上。（也可简单的使用$ hexo d -g实现部署过程）]]></content>
      <categories>
        <category>Blog Setup</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown数学公式及图表总结]]></title>
    <url>%2F2019%2F03%2F14%2FMarkdown%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E5%8F%8A%E5%9B%BE%E8%A1%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Hexo博文的编写主要基于Markdown语言。StackEdit作为一款在线Markdown编写程序，有强大的数学兼容性，后续文章的编辑主要依靠StackEdit和Typora（强烈推荐）完成。这里将展示如何用 Typora（强烈推荐）和StackEdit编写： 基本数学公式； 简单图表。 基本数学公式 行内公式$y=\alpha_1$（希腊），$\mathbf{B}$（粗体），$\mathscr{C}$（剧本字体），$\mathcal{D}$（手写），$\mathfrak{E}$（德国），$\mathbb{R}$（黑板粗体） 代码：123456$y=\alpha_1$（希腊），$\mathbf&#123;B&#125;$（粗体），$\mathscr&#123;C&#125;$（剧本字体），$\mathcal&#123;D&#125;$（手写），$\mathfrak&#123;E&#125;$（德国），$\mathbb&#123;R&#125;$（黑板粗体） 单行公式x= \int_0^1 \frac{y(t)}{5}{\rm d}t 代码： 1$$x= \int_0^1 \frac&#123;y(t)&#125;&#123;5&#125;&#123;\rm d&#125;t $$ 多行公式 使用”aligned”: \begin{aligned} H(Y|X)& = \sum_{x\in X} p(x)H(Y|X)\\ & = -\sum_{x\in X} p(x)\sum_{y\in Y}p(y|x)\log p(y|x)\\ & = -\sum_{x\in X} \sum_{y\in Y}p(y,x)\log p(y|x) \end{aligned} 代码： 12345$$\begin&#123;aligned&#125;H(Y|X)&amp; = \sum_&#123;x\in X&#125; p(x)H(Y|X)\\&amp; = -\sum_&#123;x\in X&#125; p(x)\sum_&#123;y\in Y&#125;p(y|x)\log p(y|x)\\&amp; = -\sum_&#123;x\in X&#125; \sum_&#123;y\in Y&#125;p(y,x)\log p(y|x)\end&#123;aligned&#125;$$ 使用”equation+split”: \begin{equation}\begin{split} H(Y|X)&=\sum_{x\in X} p(x)H(Y|X)\\ &=-\sum_{x\in X} p(x)\sum_{y\in Y}p(y|x)\log p(y|x)\\ &=-\sum_{x\in X} \sum_{y\in Y}p(y,x)\log p(y|x) \end{split}\end{equation} 代码： 1234567$$\begin&#123;equation&#125;\begin&#123;split&#125;H(Y|X)&amp;=\sum_&#123;x\in X&#125; p(x)H(Y|X)\\&amp;=-\sum_&#123;x\in X&#125; p(x)\sum_&#123;y\in Y&#125;p(y|x)\log p(y|x)\\&amp;=-\sum_&#123;x\in X&#125; \sum_&#123;y\in Y&#125;p(y,x)\log p(y|x)\end&#123;split&#125;\end&#123;equation&#125;$$ 使用”eqnarray”:(Maxwell equs) \begin{eqnarray} \nabla\cdot\vec{E} &=& \frac{\rho}{\epsilon_0} \\ \nabla\cdot\vec{B} &=& 0 \\ \nabla\times\vec{E} &=& -\frac{\partial B}{\partial t} \\ \nabla\times\vec{B} &=&\mu_0\left(\vec{J}+\epsilon_0\frac{\partial E}{\partial t} \right) \end{eqnarray} 代码： 12345678$$\begin&#123;eqnarray&#125;\nabla\cdot\vec&#123;E&#125; &amp;=&amp; \frac&#123;\rho&#125;&#123;\epsilon0&#125; \\\nabla\cdot\vec&#123;B&#125; &amp;=&amp; 0 \\\nabla\times\vec&#123;E&#125; &amp;=&amp; -\frac&#123;\partial B&#125;&#123;\partial t&#125; \\\nabla\times\vec&#123;B&#125; &amp;=&amp;\mu0\left(\vec&#123;J&#125;+\epsilon_0\frac&#123;\partial E&#125;&#123;\partial t&#125; \right)\end&#123;eqnarray&#125;$$ 简单矩阵 \begin{pmatrix} 1&0&0\\ 0&1&0\\ 0&0&1\\ \end{pmatrix} 代码： 12345$$\begin&#123;pmatrix&#125;1&amp;0&amp;0\\0&amp;1&amp;0\\0&amp;0&amp;1\\\end&#123;pmatrix&#125;$$ 复杂矩阵 \begin{bmatrix} 1 & a _1 & a _1 ^2 & \cdots & a _1 ^n \\ 1 & a _2 & a _2 ^2 & \cdots & a _2 ^n \\ \vdots & \vdots & \vdots & \ddots & \vdots \\ 1 & a _n & a _n ^2 & \cdots & a _n ^n \\ \end{bmatrix} 代码：1234567$$\begin&#123;bmatrix&#125;1 &amp; a _1 &amp; a _1 ^2 &amp; \cdots &amp; a _1 ^n \\1 &amp; a _2 &amp; a _2 ^2 &amp; \cdots &amp; a _2 ^n \\\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\1 &amp; a _n &amp; a _n ^2 &amp; \cdots &amp; a _n ^n \\\end&#123;bmatrix&#125;$$ 简单图表 使用”array” \begin{array}{c|lll} {↓}&{a}&{b}&{c}\\ \hline {R_1}&{c}&{b}&{a}\\ {R_2}&{b}&{c}&{c}\\ \end{array} 代码： 123456$$\begin&#123;array&#125;&#123;c|lll&#125;&#123;↓&#125;&amp;&#123;a&#125;&amp;&#123;b&#125;&amp;&#123;c&#125;\\\hline&#123;R_1&#125;&amp;&#123;c&#125;&amp;&#123;b&#125;&amp;&#123;a&#125;\\&#123;R_2&#125;&amp;&#123;b&#125;&amp;&#123;c&#125;&amp;&#123;c&#125;\\\end&#123;array&#125;$$ 使用SmartyPants ASCII HTML Single backticks &#39;Isn&#39;t this fun?&#39; ‘Isn’t this fun?’ Quotes &quot;Isn&#39;t this fun?&quot; “Isn’t this fun?” Dashes -- is en-dash, --- is em-dash — is en-dash, —- is em-dash 代码：12345| |ASCII |HTML ||----------------|-------------------------------|-----------------------------||Single backticks|`&apos;Isn&apos;t this fun?&apos;` |&apos;Isn&apos;t this fun?&apos; ||Quotes |`&quot;Isn&apos;t this fun?&quot;` |&quot;Isn&apos;t this fun?&quot; ||Dashes |`-- is en-dash, --- is em-dash`|-- is en-dash, --- is em-dash| 使用”mermaid”中的”sequenceDiagram”画顺序图sequenceDiagram Alice ->> Bob: Hello Bob, how are you? Bob-->>John: How about you John? Bob--x Alice: I am good thanks! Bob-x John: I am good thanks! Note right of John: Bob thinks a longlong time, so longthat the text doesnot fit on a row. Bob-->Alice: Checking with John... Alice->>John: Yes... John, how are you? 代码：（这里用’ . ‘代替’ ` ‘）12345678910...mermaidsequenceDiagramAlice -&gt;&gt; Bob: Hello Bob, how are you?Bob--&gt;&gt;John: How about you John?Bob--x Alice: I am good thanks!Bob-x John: I am good thanks!Note right of John: Bob thinks a long&lt;br/&gt;long time, so long&lt;br/&gt;that the text does&lt;br/&gt;not fit on a row.Bob--&gt;Alice: Checking with John...Alice-&gt;John: Yes... John, how are you?... 使用”mermaid”中的”graph LR”画流程图graph LR A[Square Rect] -- Link text --> B((Circle)) A --> C(Round Rect) B --> D{Rhombus} C --> D 代码：（这里用’ . ‘代替’ ` ‘） 1234567...mermaidgraph LRA[Square Rect] -- Link text --&gt; B((Circle))A --&gt; C(Round Rect)B --&gt; D&#123;Rhombus&#125;C --&gt; D...]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>数学公式</tag>
        <tag>图表</tag>
      </tags>
  </entry>
</search>
